[
  {
    "id": "120842",
    "name": "2차원으로 만들기",
    "fileName": "2차원으로-만들기&120842&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num_list, n) {\n  let result = [];\n  for (let i = 0; i < num_list.length / n; i++) {\n    result = [...result, num_list.slice(i * n, i * n + n)];\n  }\n  return result;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120842"
  },
  {
    "id": "120891",
    "name": "369게임",
    "fileName": "369게임&120891&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(order) {\n  return [...('' + order)].filter(num => num === '3' || num === '6' || num === '9').length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120891"
  },
  {
    "id": "120912",
    "name": "7의 개수",
    "fileName": "7의-개수&120912&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(array) {\n  return [...array.join('')].filter(a => a === '7').length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120912"
  },
  {
    "id": "120886",
    "name": "A로 B 만들기",
    "fileName": "A로-B-만들기&120886&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(before, after) {\n  const sort = str => [...str].sort((a, b) => (a < b ? -1 : a !== b ? 1 : 0)).join('');\n  return sort(before) === sort(after) ? 1 : 0;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120886"
  },
  {
    "id": "120907",
    "name": "OX퀴즈",
    "fileName": "OX퀴즈&120907&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(quiz) {\n  return quiz.map(q => {\n    const [formula, answer] = q.split('=');\n    return eval(formula) === +answer ? 'O' : 'X';\n  });\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120907"
  },
  {
    "id": "120887",
    "name": "k의 개수",
    "fileName": "k의-개수&120887&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(i, j, k) {\n  let count = 0;\n  for (let num = i; num <= j; num++) {\n    count += [...('' + num)].filter(n => +n === k).length;\n  }\n  return count;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120887"
  },
  {
    "id": "120905",
    "name": "n의 배수 고르기",
    "fileName": "n의-배수-고르기&120905&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, numlist) {\n  return numlist.filter(num => num % n === 0);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120905"
  },
  {
    "id": "120890",
    "name": "가까운 수",
    "fileName": "가까운-수&120890&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(array, n) {\n  const minDiff = Math.min(...array.map(a => Math.abs(a - n)));\n  return array.sort((a, b) => a - b).find(a => Math.abs(a - n) === minDiff);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120890"
  },
  {
    "id": "120839",
    "name": "가위 바위 보",
    "fileName": "가위-바위-보&120839&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(rsp) {\n  const win = { 0: 5, 2: 0, 5: 2 };\n  return [...rsp].map(num => win[num]).join('');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120839"
  },
  {
    "id": "120899",
    "name": "가장 큰 수 찾기",
    "fileName": "가장-큰-수-찾기&120899&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(array) {\n  const max = Math.max(...array);\n  return [max, array.indexOf(max)];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120899"
  },
  {
    "id": "120829",
    "name": "각도기",
    "fileName": "각도기&120829&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(angle) {\n  if (angle === 180) return 4;\n  if (angle > 90) return 3;\n  if (angle === 90) return 2;\n  return 1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120829"
  },
  {
    "id": "120837",
    "name": "개미 군단",
    "fileName": "개미-군단&120837&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(hp) {\n  const first = Math.floor(hp / 5);\n  const second = Math.floor((hp - first * 5) / 3);\n  const third = hp - first * 5 - second * 3;\n  return first + second + third;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120837"
  },
  {
    "id": "120876",
    "name": "겹치는 선분의 길이",
    "fileName": "겹치는-선분의-길이&120876&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(lines) {\n  const visited = lines.reduce((a, [x, y]) => {\n    for (let i = Math.min(x, y) + 1; i <= Math.max(x, y); i++) a[i] = a[i] ? a[i] + 1 : 1;\n    return a;\n  }, {});\n\n  return Object.values(visited).filter(v => v > 1).length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120876"
  },
  {
    "id": "120843",
    "name": "공 던지기",
    "fileName": "공-던지기&120843&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers, k) {\n  const goNext = current => (current + 2) % numbers.length;\n  let current = 0;\n  for (let i = 0; i < k - 1; i++) current = goNext(current);\n  return numbers[current];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120843"
  },
  {
    "id": "120840",
    "name": "구슬을 나누는 경우의 수",
    "fileName": "구슬을-나누는-경우의-수&120840&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(balls, share) {\n  const [n, m] = [balls, share];\n  const fact = [BigInt(1), BigInt(1)];\n\n  for (let i = 2; i <= n; i++) fact[i] = fact[i - 1] * BigInt(i);\n\n  return Number(fact[n] / (fact[n - m] * fact[m]));\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120840"
  },
  {
    "id": "120810",
    "name": "나머지 구하기",
    "fileName": "나머지-구하기&120810&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num1, num2) {\n  return num1 % num2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120810"
  },
  {
    "id": "120820",
    "name": "나이 출력",
    "fileName": "나이-출력&120820&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(age) {\n  return 2022 - age + 1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120820"
  },
  {
    "id": "120924",
    "name": "다음에 올 숫자",
    "fileName": "다음에-올-숫자&120924&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(common) {\n  const isAP = arr => arr[2] - arr[1] === arr[1] - arr[0];\n  return isAP(common)\n    ? common[common.length - 1] + common[1] - common[0]\n    : common[common.length - 1] * (common[1] / common[0]);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120924"
  },
  {
    "id": "120863",
    "name": "다항식 더하기",
    "fileName": "다항식-더하기&120863&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(polynomial) {\n  const countX = x => {\n    const count = x.replaceAll('x', '');\n    return count === '' ? 1 : +count;\n  };\n\n  const count = polynomial\n    .split(' + ')\n    .reduce((a, c) => (c.includes('x') ? { ...a, x: a.x + countX(c) } : { ...a, num: a.num + +c }), {\n      x: 0,\n      num: 0,\n    });\n\n  const x = count.x > 0 ? `${count.x > 1 ? count.x : ''}x` : '';\n  const num = count.num > 0 ? '' + count.num : '';\n  const plus = x !== '' && num !== '' ? ' + ' : '';\n\n  return x + plus + num;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120863"
  },
  {
    "id": "120893",
    "name": "대문자와 소문자",
    "fileName": "대문자와-소문자&120893&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  return [...my_string].map(char => (char === char.toUpperCase() ? char.toLowerCase() : char.toUpperCase())).join('');\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120893"
  },
  {
    "id": "120804",
    "name": "두 수의 곱",
    "fileName": "두-수의-곱&120804&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num1, num2) {\n  return num1 * num2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120804"
  },
  {
    "id": "120806",
    "name": "두 수의 나눗셈",
    "fileName": "두-수의-나눗셈&120806&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num1, num2) {\n  return Math.floor((num1 / num2) * 1000);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120806"
  },
  {
    "id": "120803",
    "name": "두 수의 차",
    "fileName": "두-수의-차&120803&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num1, num2) {\n  return num1 - num2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120803"
  },
  {
    "id": "120802",
    "name": "두 수의 합",
    "fileName": "두-수의-합&120802&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num1, num2) {\n  return num1 + num2\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120802"
  },
  {
    "id": "120882",
    "name": "등수 매기기",
    "fileName": "등수-매기기&120882&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(score) {\n  const avgs = score.map(([a, b]) => (a + b) / 2);\n  const avgRank = [...avgs]\n    .sort((a, b) => b - a)\n    .map((avg, i) => ({ avg, rank: i + 1 }))\n    .map((a, i, arr) => (i > 0 && a.avg === arr[i - 1].avg ? { ...a, rank: arr[i - 1].rank } : a));\n\n  return avgs.map(_avg => avgRank.find(({ avg }) => _avg === avg).rank);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120882"
  },
  {
    "id": "120883",
    "name": "로그인 성공?",
    "fileName": "로그인-성공&#63;&120883&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(id_pw, db) {\n  const [id, pw] = id_pw;\n  if (!db.find(([_id]) => _id === id)) return 'fail';\n  return db.find(([_id, _pw]) => _id === id && _pw === pw) ? 'login' : 'wrong pw';\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120883"
  },
  {
    "id": "120585",
    "name": "머쓱이보다 키 큰 사람",
    "fileName": "머쓱이보다-키-큰-사람&120585&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(array, height) {\n  return array.filter(a => a > height).length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120585"
  },
  {
    "id": "120838",
    "name": "모스부호 (1)",
    "fileName": "모스부호-(1)&120838&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(letter) {\n  const morse = { \n  '.-':'a','-...':'b','-.-.':'c','-..':'d','.':'e','..-.':'f',\n  '--.':'g','....':'h','..':'i','.---':'j','-.-':'k','.-..':'l',\n  '--':'m','-.':'n','---':'o','.--.':'p','--.-':'q','.-.':'r',\n  '...':'s','-':'t','..-':'u','...-':'v','.--':'w','-..-':'x',\n  '-.--':'y','--..':'z'\n  }\n  return letter\n    .split(' ')\n    .map(l => morse[l])\n    .join('');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120838"
  },
  {
    "id": "120849",
    "name": "모음 제거",
    "fileName": "모음-제거&120849&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  return my_string.replace(/[aeiou]/g, '');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120849"
  },
  {
    "id": "120805",
    "name": "몫 구하기",
    "fileName": "몫-구하기&120805&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num1, num2) {\n  return Math.floor(num1 / num2);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120805"
  },
  {
    "id": "120825",
    "name": "문자 반복 출력하기",
    "fileName": "문자-반복-출력하기&120825&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string, n) {\n  return [...my_string].map(char => char.repeat(n)).join('');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120825"
  },
  {
    "id": "120902",
    "name": "문자열 계산하기",
    "fileName": "문자열-계산하기&120902&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  return eval(my_string);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120902"
  },
  {
    "id": "120822",
    "name": "문자열 뒤집기",
    "fileName": "문자열-뒤집기&120822&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  return [...my_string].reverse().join('');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120822"
  },
  {
    "id": "120921",
    "name": "문자열 밀기",
    "fileName": "문자열-밀기&120921&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(A, B) {\n  const pushRight = str => [str[str.length - 1], ...str.slice(0, str.length - 1)].join('');\n  for (let i = 0; i <= A.length; i++) {\n    if (A === B) return i;\n    A = pushRight(A);\n  }\n\n  return -1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120921"
  },
  {
    "id": "120850",
    "name": "문자열 정렬하기 (1)",
    "fileName": "문자열-정렬하기-(1)&120850&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  return my_string\n    .match(/[0-9]/g)\n    .map(str => +str)\n    .sort((a, b) => a - b);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120850"
  },
  {
    "id": "120911",
    "name": "문자열 정렬하기 (2)",
    "fileName": "문자열-정렬하기-(2)&120911&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  return [...my_string]\n    .map(char => char.toLowerCase())\n    .sort((a, b) => (a < b ? -1 : a > b ? 1 : 0))\n    .join('');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120911"
  },
  {
    "id": "120908",
    "name": "문자열안에 문자열",
    "fileName": "문자열안에-문자열&120908&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(str1, str2) {\n  return str1.includes(str2) ? 1 : 2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120908"
  },
  {
    "id": "120809",
    "name": "배열 두 배 만들기",
    "fileName": "배열-두-배-만들기&120809&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n  return numbers.map(n => n * 2);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120809"
  },
  {
    "id": "120821",
    "name": "배열 뒤집기",
    "fileName": "배열-뒤집기&120821&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num_list) {\n  return num_list.reverse();\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120821"
  },
  {
    "id": "120854",
    "name": "배열 원소의 길이",
    "fileName": "배열-원소의-길이&120854&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(strlist) {\n  return strlist.map(s => s.length);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120854"
  },
  {
    "id": "120833",
    "name": "배열 자르기",
    "fileName": "배열-자르기&120833&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers, num1, num2) {\n  return numbers.slice(num1, num2 + 1);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120833"
  },
  {
    "id": "120844",
    "name": "배열 회전시키기",
    "fileName": "배열-회전시키기&120844&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers, direction) {\n  return direction === 'right'\n    ? [numbers[numbers.length - 1], ...numbers.slice(0, numbers.length - 1)]\n    : [...numbers.slice(1), numbers[0]];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120844"
  },
  {
    "id": "120903",
    "name": "배열의 유사도",
    "fileName": "배열의-유사도&120903&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s1, s2) {\n  return s1.filter(s => s2.includes(s)).length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120903"
  },
  {
    "id": "120817",
    "name": "배열의 평균값",
    "fileName": "배열의-평균값&120817&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n  return numbers.reduce((a, c) => a + c, 0) / numbers.length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120817"
  },
  {
    "id": "120808",
    "name": "분수의 덧셈",
    "fileName": "분수의-덧셈&120808&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(denum1, num1, denum2, num2) {\n  const denum = denum2 * num1 + denum1 * num2;\n  const num = num1 * num2;\n  const getGCD = (a, b) => (b === 0 ? a : getGCD(b, a % b));\n  const gcd = getGCD(denum, num);\n  return [denum / gcd, num / gcd];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120808"
  },
  {
    "id": "120889",
    "name": "삼각형의 완성조건 (1)",
    "fileName": "삼각형의-완성조건-(1)&120889&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(sides) {\n  const max = Math.max(...sides);\n  return max < sides.reduce((a, c) => a + c, 0) - max ? 1 : 2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120889"
  },
  {
    "id": "120868",
    "name": "삼각형의 완성조건 (2)",
    "fileName": "삼각형의-완성조건-(2)&120868&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(sides) {\n  const min = Math.min(...sides);\n  const max1 = Math.max(...sides);\n  const max2 = min + max1 - 1;\n  return max2 - (max1 - min);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120868"
  },
  {
    "id": "120910",
    "name": "세균 증식",
    "fileName": "세균-증식&120910&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, t) {\n  return n * 2 ** t;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120910"
  },
  {
    "id": "120852",
    "name": "소인수분해",
    "fileName": "소인수분해&120852&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  let pFactors = [];\n  for (let i = 2; i <= Math.sqrt(n); i++) {\n    while (n % i === 0) {\n      pFactors = [...pFactors, i];\n      n /= i;\n    }\n  }\n  if (n >= 2) pFactors = [...pFactors, n];\n  return [...new Set(pFactors)].sort((a, b) => a - b);\n}\n\nconst funcB = () => {\n  return new Promise(resolve => {\n    setTimeout(resolve('guys'), 1000);\n  });\n};\n\nconst funcC = async () => {\n  const m = 1;\n  const res = await funcB();\n  return res;\n};\nwindow.addEventListener('DOMContentLoaded', async () => {\n  console.log(await funcC());\n});\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120852"
  },
  {
    "id": "120836",
    "name": "순서쌍의 개수",
    "fileName": "순서쌍의-개수&120836&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  let count = 0;\n  for (let i = 1; i < Math.sqrt(n); i++) {\n    if (n % i === 0) count += 2;\n  }\n  if (n % Math.sqrt(n) === 0) count += 1;\n  return count;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120836"
  },
  {
    "id": "120851",
    "name": "숨어있는 숫자의 덧셈 (1)",
    "fileName": "숨어있는-숫자의-덧셈-(1)&120851&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  return my_string.match(/[0-9]/g).reduce((a, c) => a + +c, 0);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120851"
  },
  {
    "id": "120864",
    "name": "숨어있는 숫자의 덧셈 (2)",
    "fileName": "숨어있는-숫자의-덧셈-(2)&120864&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  const nums = my_string.match(/[0-9]+/g);\n  return nums ? nums.map(num => +num).reduce((a, c) => a + c, 0) : 0;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120864"
  },
  {
    "id": "120807",
    "name": "숫자 비교하기",
    "fileName": "숫자-비교하기&120807&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num1, num2) {\n  return num1 === num2 ? 1 : -1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120807"
  },
  {
    "id": "120904",
    "name": "숫자 찾기",
    "fileName": "숫자-찾기&120904&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num, k) {\n  const index = [...('' + num)].findIndex(n => +n === k);\n  return index === -1 ? -1 : index + 1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120904"
  },
  {
    "id": "120819",
    "name": "아이스 아메리카노",
    "fileName": "아이스-아메리카노&120819&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(money) {\n  return [Math.floor(money / 5500), money % 5500];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120819"
  },
  {
    "id": "120866",
    "name": "안전지대",
    "fileName": "안전지대&120866&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(board) {\n  const isBombNearby = (r, c) => {\n    const nearby = [\n      [-1, -1],\n      [-1, 0],\n      [-1, 1],\n      [0, -1],\n      [0, 1],\n      [1, -1],\n      [1, 0],\n      [1, 1],\n    ];\n\n    const isInBoard = (r, c) => r >= 0 && r < board.length && c >= 0 && c < board.length;\n\n    return nearby.some(([dR, dC]) => isInBoard(r + dR, c + dC) && board[r + dR][c + dC] === 1);\n  };\n\n  let count = 0;\n\n  for (let r = 0; r < board.length; r++) {\n    for (let c = 0; c < board.length; c++) {\n      if (board[r][c] !== 1 && !isBombNearby(r, c)) count += 1;\n    }\n  }\n  return count;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120866"
  },
  {
    "id": "120892",
    "name": "암호 해독",
    "fileName": "암호-해독&120892&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(cipher, code) {\n  return [...cipher].reduce((a, c, i) => ((i + 1) % code === 0 ? a + c : a), '');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120892"
  },
  {
    "id": "120897",
    "name": "약수 구하기",
    "fileName": "약수-구하기&120897&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  let answer = [];\n  for (let i = 1; i < Math.sqrt(n); i++) {\n    if (n % i === 0) answer = [...answer, i, n / i];\n  }\n  if (Number.isInteger(Math.sqrt(n))) answer = [...answer, Math.sqrt(n)];\n  return answer.sort((a, b) => a - b);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120897"
  },
  {
    "id": "120830",
    "name": "양꼬치",
    "fileName": "양꼬치&120830&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, k) {\n  return n * 12000 + (k - Math.floor(n / 10)) * 2000;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120830"
  },
  {
    "id": "120923",
    "name": "연속된 수의 합",
    "fileName": "연속된-수의-합&120923&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num, total) {\n  const numArr = Array.from({ length: num }, (_, i) => i);\n  const sum = numArr.reduce((a, c) => a + c);\n  return numArr.map(n => n - (sum - total) / num);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120923"
  },
  {
    "id": "120894",
    "name": "영어가 싫어요",
    "fileName": "영어가-싫어요&120894&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n  const nums = { zero: 0, one: 1, two: 2, three: 3, four: 4, five: 5, six: 6, seven: 7, eight: 8, nine: 9 };\n  const regex = new RegExp(Object.keys(nums).join('|'), 'g');\n  return +numbers.replace(regex, key => nums[key]);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120894"
  },
  {
    "id": "120818",
    "name": "옷가게 할인 받기",
    "fileName": "옷가게-할인-받기&120818&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(price) {\n  if (price >= 500000) return Math.floor(price * 0.8);\n  if (price >= 300000) return Math.floor(price * 0.9);\n  if (price >= 100000) return Math.floor(price * 0.95);\n  return price;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120818"
  },
  {
    "id": "120956",
    "name": "옹알이",
    "fileName": "옹알이&120956&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(babbling) {\n  const convertPWordsToNum = word => {\n    const pWords = ['aya', 'ye', 'woo', 'ma'];\n    return pWords.reduce((result, pWord, i) => result.replaceAll(pWord, i), word);\n  };\n  const canPronounce = word => {\n    const result = convertPWordsToNum(word);\n    return !/[^\\d]/.test(result) && [...result].every((num, i) => i + 1 > result.length || num !== result[i + 1]);\n  };\n\n  return babbling.filter(b => canPronounce(b)).length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120956"
  },
  {
    "id": "120869",
    "name": "외계어 사전",
    "fileName": "외계어-사전&120869&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(spell, dic) {\n  const sort = str => [...str].sort((a, b) => (a < b ? -1 : a !== b ? 1 : 0)).join('');\n  return dic.find(dic => sort(dic) === sort(spell.join(''))) ? 1 : 2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120869"
  },
  {
    "id": "120834",
    "name": "외계행성의 나이",
    "fileName": "외계행성의-나이&120834&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(age) {\n  return [...('' + age)].map(num => String.fromCharCode('a'.charCodeAt(0) + +num)).join('');\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120834"
  },
  {
    "id": "120878",
    "name": "유한소수 판별하기",
    "fileName": "유한소수-판별하기&120878&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(a, b) {\n  const getGCD = (a, b) => {\n    let gcd = 1;\n    for (let i = 1; i <= Math.min(a, b); i++) {\n      if (a % i === 0 && b % i === 0) gcd = i;\n    }\n    return gcd;\n  };\n\n  const getPrimeFactors = num => {\n    let pFactors = [];\n    for (let i = 2; i <= Math.sqrt(num); i++) {\n      while (num % i === 0) {\n        pFactors = [...pFactors, i];\n        num /= i;\n      }\n    }\n    if (num > 2) pFactors = [...pFactors, num];\n    return pFactors;\n  };\n\n  return getPrimeFactors(b / getGCD(a, b)).find(n => n !== 2 && n !== 5) ? 2 : 1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120878"
  },
  {
    "id": "120885",
    "name": "이진수 더하기",
    "fileName": "이진수-더하기&120885&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(bin1, bin2) {\n  return (parseInt(bin1, 2) + parseInt(bin2, 2)).toString(2);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120885"
  },
  {
    "id": "120895",
    "name": "인덱스 바꾸기",
    "fileName": "인덱스-바꾸기&120895&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string, num1, num2) {\n  const str = [...my_string];\n\n  [str[num1], str[num2]] = [str[num2], str[num1]];\n\n  return str.join('');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120895"
  },
  {
    "id": "120906",
    "name": "자릿수 더하기",
    "fileName": "자릿수-더하기&120906&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  return [...('' + n)].map(num => +num).reduce((a, c) => a + c, 0);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120906"
  },
  {
    "id": "120913",
    "name": "잘라서 배열로 저장하기",
    "fileName": "잘라서-배열로-저장하기&120913&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_str, n) {\n  let result = [];\n  for (let i = 0; i < my_str.length / n; i++) result = [...result, my_str.slice(i * n, i * n + n)];\n  return result;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120913"
  },
  {
    "id": "120871",
    "name": "저주의 숫자 3",
    "fileName": "저주의-숫자-3&120871&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  let num = 0;\n  let count = 0;\n\n  while (count < n) {\n    num += 1;\n    if (!('' + num).includes('3') && num % 3 !== 0) count += 1;\n  }\n\n  return num;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120871"
  },
  {
    "id": "120841",
    "name": "점의 위치 구하기",
    "fileName": "점의-위치-구하기&120841&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(dot) {\n  const [x, y] = dot;\n  if (y > 0) return x > 0 ? 1 : 2;\n  return x < 0 ? 3 : 4;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120841"
  },
  {
    "id": "120909",
    "name": "제곱수 판별하기",
    "fileName": "제곱수-판별하기&120909&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  return Number.isInteger(Math.sqrt(n)) ? 1 : 2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120909"
  },
  {
    "id": "120922",
    "name": "종이 자르기",
    "fileName": "종이-자르기&120922&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(M, N) {\n  return M * N - 1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120922"
  },
  {
    "id": "120845",
    "name": "주사위의 개수",
    "fileName": "주사위의-개수&120845&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(box, n) {\n  return Math.floor(box[0] / n) * Math.floor(box[1] / n) * Math.floor(box[2] / n);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120845"
  },
  {
    "id": "120888",
    "name": "중복된 문자 제거",
    "fileName": "중복된-문자-제거&120888&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string) {\n  return [...new Set(my_string)].join('');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120888"
  },
  {
    "id": "120583",
    "name": "중복된 숫자 개수",
    "fileName": "중복된-숫자-개수&120583&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(array, n) {\n  return array.filter(a => a === n).length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120583"
  },
  {
    "id": "120811",
    "name": "중앙값 구하기",
    "fileName": "중앙값-구하기&120811&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(array) {\n  return array.sort((a, b) => a - b)[Math.floor(array.length / 2)];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120811"
  },
  {
    "id": "120823",
    "name": "직각삼각형 출력하기",
    "fileName": "직각삼각형-출력하기&120823&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nconst readline = require('readline');\nconst rl = readline.createInterface({\n  input: process.stdin,\n  output: process.stdout,\n});\n\nlet input = [];\n\nrl.on('line', function (line) {\n  input = line.split(' ');\n}).on('close', function () {\n  for (let i = 1; i <= +input[0]; i++) console.log('*'.repeat(i));\n});\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120823"
  },
  {
    "id": "120860",
    "name": "직사각형 넓이 구하기",
    "fileName": "직사각형-넓이-구하기&120860&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(dots) {\n  const xDots = dots.flatMap(([x, y]) => x);\n  const yDots = dots.flatMap(([x, y]) => y);\n  const width = Math.max(...xDots) - Math.min(...xDots);\n  const height = Math.max(...yDots) - Math.min(...yDots);\n  return width * height;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120860"
  },
  {
    "id": "120835",
    "name": "진료순서 정하기",
    "fileName": "진료순서-정하기&120835&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(emergency) {\n  const sorted = [...emergency].sort((a, b) => b - a);\n  return emergency.map(e => sorted.findIndex(s => s === e) + 1);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120835"
  },
  {
    "id": "120824",
    "name": "짝수 홀수 개수",
    "fileName": "짝수-홀수-개수&120824&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(num_list) {\n  const evenLength = num_list.filter(n => n % 2 === 0).length;\n  return [evenLength, num_list.length - evenLength];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120824"
  },
  {
    "id": "120813",
    "name": "짝수는 싫어요",
    "fileName": "짝수는-싫어요&120813&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  let nums = [];\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 1) nums = [...nums, i];\n  }\n  return nums;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120813"
  },
  {
    "id": "120831",
    "name": "짝수의 합",
    "fileName": "짝수의-합&120831&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  let answer = 0;\n  for (let i = 0; i <= n; i++) {\n    if (i % 2 === 0) answer += i;\n  }\n  return answer;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120831"
  },
  {
    "id": "120847",
    "name": "최댓값 만들기(1)",
    "fileName": "최댓값-만들기(1)&120847&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n  const [first, second, ...rest] = numbers.sort((a, b) => b - a);\n  return first * second;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120847"
  },
  {
    "id": "120862",
    "name": "최댓값 만들기 (2)",
    "fileName": "최댓값-만들기-(2)&120862&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n  const sorted = numbers.sort((a, b) => a - b);\n  return Math.max(sorted[0] * sorted[1], sorted[sorted.length - 1] * sorted[sorted.length - 2]);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120862"
  },
  {
    "id": "120812",
    "name": "최빈값 구하기",
    "fileName": "최빈값-구하기&120812&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(array) {\n  const counts = array.reduce((a, c) => (a[c] ? { ...a, [c]: a[c] + 1 } : { ...a, [c]: 1 }), {});\n  const max = Math.max(...Object.values(counts));\n  const modes = Object.keys(counts).filter(key => counts[key] === max);\n  return modes.length === 1 ? +modes[0] : -1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120812"
  },
  {
    "id": "120884",
    "name": "치킨 쿠폰",
    "fileName": "치킨-쿠폰&120884&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(chicken) {\n  const order = coupons => {\n    if (coupons < 10) return 0;\n    const service = Math.floor(coupons / 10);\n    return service + order(service + (coupons % 10));\n  };\n  return order(chicken);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120884"
  },
  {
    "id": "120861",
    "name": "캐릭터의 좌표",
    "fileName": "캐릭터의-좌표&120861&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(keyinput, board) {\n  const moves = {\n    up: [0, 1],\n    down: [0, -1],\n    left: [-1, 0],\n    right: [1, 0],\n  };\n  const [rangeX, rangeY] = [Math.floor(board[0] / 2), Math.floor(board[1] / 2)];\n\n  return keyinput\n    .map(key => moves[key])\n    .reduce(\n      ([x, y], [mX, mY]) => (Math.abs(x + mX) > rangeX || Math.abs(y + mY) > rangeY ? [x, y] : [x + mX, y + mY]),\n      [0, 0]\n    );\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120861"
  },
  {
    "id": "120853",
    "name": "컨트롤 제트",
    "fileName": "컨트롤-제트&120853&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n  const arr = s.split(' ');\n  while (arr.includes('Z')) arr.splice(arr.indexOf('Z') - 1, 2);\n  return arr.map(n => +n).reduce((a, c) => a + c, 0);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120853"
  },
  {
    "id": "120880",
    "name": "특이한 정렬",
    "fileName": "특이한-정렬&120880&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numlist, n) {\n  return numlist.sort((a, b) => {\n    const [aDiff, bDiff] = [Math.abs(a - n), Math.abs(b - n)];\n    if (aDiff === bDiff) return b - a;\n    return aDiff - bDiff;\n  });\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120880"
  },
  {
    "id": "120826",
    "name": "특정 문자 제거하기",
    "fileName": "특정-문자-제거하기&120826&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(my_string, letter) {\n  return my_string.replaceAll(letter, '');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120826"
  },
  {
    "id": "120848",
    "name": "팩토리얼",
    "fileName": "팩토리얼&120848&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  let factorial = [1, 1];\n  for (let i = 2; n > factorial[i - 1]; i++) factorial[i] = factorial[i - 1] * i;\n\n  return factorial[factorial.length - 1] === n ? factorial.length - 1 : factorial.length - 2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120848"
  },
  {
    "id": "120898",
    "name": "편지",
    "fileName": "편지&120898&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(message) {\n  return message.length * 2;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120898"
  },
  {
    "id": "120875",
    "name": "평행",
    "fileName": "평행&120875&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(dots) {\n  const getInclination = ([[x1, y1], [x2, y2]]) => (x2 !== x1 ? (y2 - y1) / (x2 - x1) : Infinity);\n  const isParallel = (line1, line2) => getInclination(line1) === getInclination(line2);\n\n  return dots.some(dot => {\n    const line1 = [dots[0], dot];\n    const line2 = dots.filter(dot => !line1.includes(dot));\n    return isParallel(line1, line2);\n  })\n    ? 1\n    : 0;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120875"
  },
  {
    "id": "120814",
    "name": "피자 나눠 먹기 (1)",
    "fileName": "피자-나눠-먹기-(1)&120814&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  return Math.floor((n - 1) / 7) + 1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120814"
  },
  {
    "id": "120815",
    "name": "피자 나눠 먹기 (2)",
    "fileName": "피자-나눠-먹기-(2)&120815&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  const getLCM = (a, b) => {\n    let lcm = 1;\n    while ((lcm % a !== 0 || lcm % b !== 0) && lcm < a * b) lcm += 1;\n    return lcm;\n  };\n\n  return getLCM(n, 6) / 6;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120815"
  },
  {
    "id": "120816",
    "name": "피자 나눠 먹기 (3)",
    "fileName": "피자-나눠-먹기-(3)&120816&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(slice, n) {\n  return Math.floor((n - 1) / slice) + 1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120816"
  },
  {
    "id": "120896",
    "name": "한 번만 등장한 문자",
    "fileName": "한-번만-등장한-문자&120896&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n  const count = [...s].reduce((a, c) => (a[c] ? { ...a, [c]: a[c] + 1 } : { ...a, [c]: 1 }), {});\n  return Object.keys(count)\n    .filter(key => count[key] === 1)\n    .sort((a, b) => (a < b ? -1 : a > b ? 1 : 0))\n    .join('');\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120896"
  },
  {
    "id": "120846",
    "name": "합성수 찾기",
    "fileName": "합성수-찾기&120846&.js",
    "level": 0,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  const isPrime = num => {\n    for (let i = 2; i <= Math.sqrt(num); i++) {\n      if (num % i === 0) return true;\n    }\n    return false;\n  };\n\n  let count = 0;\n\n  for (let i = 1; i <= n; i++) {\n    if (isPrime(i)) count += 1;\n  }\n  \n  return count;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/120846"
  },
  {
    "id": "12901",
    "name": "2016년",
    "fileName": "2016년&12901&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(a, b) {\n  let count = 0;\n  const day = [\"SUN\", \"MON\", \"TUE\", \"WED\", \"THU\", \"FRI\", \"SAT\"];\n  const month = [0, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n  for (let i = 1; i < a; i++) count += month[i];\n  count += b;\n  return day[(count + 4) % 7]; // 금요일 부터 1일 이므로\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12901"
  },
  {
    "id": "68935",
    "name": "3진법 뒤집기",
    "fileName": "3진법-뒤집기&68935&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return parseInt(n.toString(3).split(\"\").reverse().join(\"\"), 3);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/68935"
  },
  {
    "id": "42748",
    "name": "K번째수",
    "fileName": "K번째수&42748&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(array, commands) {\n  return commands.map((cmd) => {\n    const arrCmd = array.slice(cmd[0] - 1, cmd[1]).sort((a, b) => a - b);\n    return arrCmd[cmd[2] - 1];\n  });\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42748"
  },
  {
    "id": "17682",
    "name": "[1차] 다트 게임",
    "fileName": "[1차]-다트-게임&17682&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(dartResult) {\n  const regex = /\\d{1,2}[SDT]{1}[*|#]?/g;\n  let result = [];\n  for (const dart of dartResult.match(regex)) {\n    const game = [...dart.split(/([SDT]{1})/)];\n    const score = game[0];\n    let bonus = 1;\n    let option = 1;\n    if (game[1] === \"S\") bonus = 1;\n    if (game[1] === \"D\") bonus = 2;\n    if (game[1] === \"T\") bonus = 3;\n\n    if (game[2] === \"*\") {\n      if (result.length !== 0) result[result.length - 1] *= 2;\n      option = 2;\n    }\n    if (game[2] === \"#\") option = -1;\n\n    result.push(score ** bonus * option);\n  }\n\n  return result.reduce((a, b) => a + b);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17682"
  },
  {
    "id": "17681",
    "name": "[1차] 비밀지도",
    "fileName": "[1차]-비밀지도&17681&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n, arr1, arr2) {\n  const answer = [];\n  for (let i = 0; i < n; i++) {\n    let row = (arr1[i] | arr2[i]).toString(2); //Bitwise\n    row = \"0\".repeat(n - row.length) + row;\n    row = row.replace(/[10]/g, (a) => (+a ? \"#\" : \" \"));\n    answer.push(row);\n  }\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17681"
  },
  {
    "id": "12954",
    "name": "x만큼 간격이 있는 n개의 숫자",
    "fileName": "x만큼-간격이-있는-n개의-숫자&12954&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(x, n) {\n  return Array.from(Array(n), (_, index) => x * (index + 1));\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12954"
  },
  {
    "id": "12903",
    "name": "가운데 글자 가져오기",
    "fileName": "가운데-글자-가져오기&12903&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return s.length % 2 !== 0\n    ? s[Math.floor(s.length / 2)]\n    : s.slice(s.length / 2 - 1, s.length / 2 + 1);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12903"
  },
  {
    "id": "12906",
    "name": "같은 숫자는 싫어",
    "fileName": "같은-숫자는-싫어&12906&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr) {\n  return arr.filter((element, index) => element !== arr[index + 1]);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12906"
  },
  {
    "id": "12910",
    "name": "나누어 떨어지는 숫자 배열",
    "fileName": "나누어-떨어지는-숫자-배열&12910&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr, divisor) {\n  const answer = arr.filter((element) => element % divisor === 0);\n  answer.length === 0 ? answer.push(-1) : answer.sort((a, b) => a - b);\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12910"
  },
  {
    "id": "87389",
    "name": "나머지가 1이 되는 수 찾기",
    "fileName": "나머지가-1이-되는-수-찾기&87389&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n\n  let answer = 0;\n  for (let divisor = n - 1; divisor >= 2; divisor--) {\n    if (n % divisor === 1) answer = divisor;\n  }\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/87389"
  },
  {
    "id": "70128",
    "name": "내적",
    "fileName": "내적&70128&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(a, b) {\n  return a.reduce((x, y, i) => x + y * b[i], 0);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/70128"
  },
  {
    "id": "68644",
    "name": "두 개 뽑아서 더하기",
    "fileName": "두-개-뽑아서-더하기&68644&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(numbers) {\n  const answer = [];\n  for (let i = 0; i < numbers.length; i++) {\n    for (let j = i + 1; j < numbers.length; j++) {\n      answer.push(numbers[i] + numbers[j]);\n    }\n  }\n  return [...new Set(answer)].sort((a, b) => a - b);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/68644"
  },
  {
    "id": "12912",
    "name": "두 정수 사이의 합",
    "fileName": "두-정수-사이의-합&12912&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(a, b) {\n  let answer = 0;\n  for (let i = Math.min(a, b); i <= Math.max(a, b); i++) {\n    answer += i;\n  }\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12912"
  },
  {
    "id": "77484",
    "name": "로또의 최고 순위와 최저 순위",
    "fileName": "로또의-최고-순위와-최저-순위&77484&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(lottos, win_nums) {\n  const zeroCount = lottos.filter((e) => e === 0).length;\n  const matchCount = win_nums.filter((e) => lottos.includes(e)).length;\n  const matchToRank = [6, 6, 5, 4, 3, 2, 1];\n  const lowRank = matchToRank[matchCount];\n  const highRank = zeroCount === 6 ? 1 : matchToRank[matchCount + zeroCount];\n\n  return [highRank, lowRank];\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/77484"
  },
  {
    "id": "42840",
    "name": "모의고사",
    "fileName": "모의고사&42840&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(answers) {\n  const answer = [];\n  const firstPattern = [1, 2, 3, 4, 5];\n  const firstPLength = firstPattern.length;\n  const secondPattern = [2, 1, 2, 3, 2, 4, 2, 5];\n  const secondPLength = secondPattern.length;\n  const thirdPattern = [3, 3, 1, 1, 2, 2, 4, 4, 5, 5];\n  const thirdLength = thirdPattern.length;\n  let correctCount = [0, 0, 0];\n\n  for (let i = 0, len = answers.length; i < len; i++) {\n    if (answers[i] === firstPattern[i % firstPLength]) correctCount[0] += 1;\n    if (answers[i] === secondPattern[i % secondPLength]) correctCount[1] += 1;\n    if (answers[i] === thirdPattern[i % thirdLength]) correctCount[2] += 1;\n  }\n\n  const maxScore = Math.max(...correctCount);\n  for (let i = 0; i < 3; i++) {\n    if (correctCount[i] === maxScore) answer.push(i + 1);\n  }\n\n  return answer;\n}\n\n// 완벽한 정답이 아닙니다.\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42840"
  },
  {
    "id": "12916",
    "name": "문자열 내 p와 y의 개수",
    "fileName": "문자열-내-p와-y의-개수&12916&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  const countP = [...s.matchAll(/p/gi)].length;\n  const countY = [...s.matchAll(/y/gi)].length;\n  return countP === countY;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12916"
  },
  {
    "id": "12915",
    "name": "문자열 내 마음대로 정렬하기",
    "fileName": "문자열-내-마음대로-정렬하기&12915&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(strings, n) {\n  return strings.sort((a, b) => {\n    if (a[n] < b[n]) return -1;\n    if (a[n] > b[n]) return 1;\n    if (a[n] === b[n]) return a < b ? -1 : 1;\n    return 0;\n  });\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12915"
  },
  {
    "id": "12917",
    "name": "문자열 내림차순으로 배치하기",
    "fileName": "문자열-내림차순으로-배치하기&12917&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return s\n    .split(\"\")\n    .sort((a, b) => {\n      if (a < b) return 1;\n      if (a > b) return -1;\n      return 0;\n    })\n    .join(\"\");\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12917"
  },
  {
    "id": "12918",
    "name": "문자열 다루기 기본",
    "fileName": "문자열-다루기-기본&12918&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return s.search(/\\D/g) < 0 && (s.length === 4 || s.length === 6);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12918"
  },
  {
    "id": "12925",
    "name": "문자열을 정수로 바꾸기",
    "fileName": "문자열을-정수로-바꾸기&12925&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return parseInt(s);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12925"
  },
  {
    "id": "82612",
    "name": "부족한 금액 계산하기",
    "fileName": "부족한-금액-계산하기&82612&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(price, money, count) {\n  let totalCost = 0;\n  for (let i = 1; i <= count; i++) totalCost += price * i;\n  return totalCost <= money ? 0 : totalCost - money;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/82612"
  },
  {
    "id": "12919",
    "name": "서울에서 김서방 찾기",
    "fileName": "서울에서-김서방-찾기&12919&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(seoul) {\n  return `김서방은 ${seoul.indexOf(\"Kim\")}에 있다`;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12919"
  },
  {
    "id": "118666",
    "name": "성격 유형 검사하기",
    "fileName": "성격-유형-검사하기&118666&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - ssi02014\nfunction solution(survey, choices) {\n  const points = [3, 2, 1, 0, 1, 2, 3];\n  const pointBoard = {\n    R: 0,\n    T: 0,\n    C: 0,\n    F: 0,\n    J: 0,\n    M: 0,\n    A: 0,\n    N: 0,\n  };\n  let result = \"\";\n\n  // 카테고리 별 점수 추가\n  for (let i = 0; i < survey.length; i++) {\n    const categories = survey[i];\n\n    if (choices[i] < 4) {\n      pointBoard[categories[0]] += points[choices[i] - 1];\n    } else if (choices[i] > 4) {\n      pointBoard[categories[1]] += points[choices[i] - 1];\n    }\n  }\n\n  const pointBoardEntries = Object.entries(pointBoard);\n\n  // 지표에 맞게 결과 값 도출\n  for (let i = 0; i < pointBoardEntries.length; i += 2) {\n    const [curCategory, curValue] = pointBoardEntries[i];\n    const [nextCategory, nextValue] = pointBoardEntries[i + 1];\n\n    if (curValue < nextValue) {\n      result += nextCategory;\n    } else {\n      result += curCategory;\n    }\n  }\n\n  return result;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/118666"
  },
  {
    "id": "12977",
    "name": "소수 만들기",
    "fileName": "소수-만들기&12977&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(nums) {\n  let answer = 0;\n  const length = nums.length;\n  for (let i = 0; i < length; i++) {\n    for (let j = i + 1; j < length; j++) {\n      for (let k = j + 1; k < length; k++) {\n        const sum = nums[i] + nums[j] + nums[k];\n        if (isPrime(sum)) answer += 1;\n      }\n    }\n  }\n\n  return answer;\n}\n\nfunction isPrime(num) {\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return num >= 2;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12977"
  },
  {
    "id": "42839",
    "name": "소수 찾기",
    "fileName": "소수-찾기&42839&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(numbers) {\n  let answer = 0;\n  const numArr = numbers.split(\"\");\n  const permutationAll = [];\n  for (let r = 1; r <= numbers.length; r++) {\n    const permutationR = Permutation(numArr, r).map((arr) =>\n      parseInt(arr.join(\"\"))\n    );\n    for (let i = 0; i < permutationR.length; i++)\n      permutationAll.push(permutationR[i]);\n  }\n  const permutationSet = [...new Set(permutationAll)];\n  for (const number of permutationSet) {\n    if (isPrime(number)) answer += 1;\n  }\n  return answer;\n}\n\nfunction Permutation(arr, r) {\n  const result = [];\n  if (r === 1) return arr.map((num) => [num]);\n  arr.forEach((fixed, index, org) => {\n    const rest = [...org.slice(0, index), ...org.slice(index + 1)];\n    const permutation = Permutation(rest, r - 1);\n    const attached = permutation.map((numbers) => [fixed, ...numbers]);\n    result.push(...attached);\n  });\n  return result;\n}\n\nfunction isPrime(num) {\n  for (let i = 2; i <= Math.sqrt(num); i++) {\n    if (num % i === 0) return false;\n  }\n  return num >= 2;\n}\n\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42839"
  },
  {
    "id": "12922",
    "name": "수박수박수박수박수박수?",
    "fileName": "수박수박수박수박수박수&#63;&12922&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  let answer = '';\n  for (let i = 0; i < n; i++) {\n    answer += i % 2 === 0 ? '수' : '박';\n  }\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12922"
  },
  {
    "id": "81301",
    "name": "숫자 문자열과 영단어",
    "fileName": "숫자-문자열과-영단어&81301&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  const stringToNum = [\n    \"zero\",\n    \"one\",\n    \"two\",\n    \"three\",\n    \"four\",\n    \"five\",\n    \"six\",\n    \"seven\",\n    \"eight\",\n    \"nine\",\n  ];\n  for (let i = 0; i < 10; i++) {\n    s = s.split(stringToNum[i]).join(i);\n  }\n  return parseInt(s);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/81301"
  },
  {
    "id": "131128",
    "name": "숫자 짝꿍",
    "fileName": "숫자-짝꿍&131128&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - ssi02014\n\n/**\n * X, Y의 길이가 굉장히 길어서 공통 숫자를 뽑아낼 때 객체를 이용해 연산 횟수 최적화\n * X, Y를 배열로 변환 후에 배열 메서드를 사용해도 되지만, for of문보다 효율성 떨어짐 \n * (테스트 케이스 11 ~ 15 100ms~200ms 차이)\n */\nfunction solution(X, Y) {\n  const commons = [];\n  const obj = {};\n\n  for (const el of X) {\n    obj[el] = (obj[el] || 0) + 1;\n  }\n\n  for (const el of Y) {\n    if (obj[el]) {\n      commons.push(el);\n      obj[el]--;\n    }\n  }\n\n  commons.sort((a, b) => b - a);\n\n  if (!commons.length) return \"-1\";\n  else if (commons[0] === \"0\") return \"0\";\n  return commons.join(\"\");\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/131128"
  },
  {
    "id": "12926",
    "name": "시저 암호",
    "fileName": "시저-암호&12926&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s, n) {\n  return s\n    .split(\"\")\n    .map((element) => {\n      if (element === \" \") return \" \";\n      const code = element.charCodeAt(0);\n      if ((code + n > 90 && code <= 90) || code + n > 122) {\n        return String.fromCharCode(code + n - 26);\n      } else {\n        return String.fromCharCode(code + n);\n      }\n    })\n    .join(\"\");\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12926"
  },
  {
    "id": "92334",
    "name": "신고 결과 받기",
    "fileName": "신고-결과-받기&92334&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(id_list, report, k) {\n  const reportResult = report.reduce((a, c) => {\n    const [user, reported] = c.split(' ');\n    a[reported] = a[reported] ? a[reported].add(user) : new Set().add(user);\n    return a;\n  }, {});\n\n  const mailed = Object.values(reportResult)\n    .filter(set => set.size >= k)\n    .flatMap(set => [...set]);\n  return id_list.map(id => mailed.filter(user => user === id).length);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/92334"
  },
  {
    "id": "72410",
    "name": "신규 아이디 추천",
    "fileName": "신규-아이디-추천&72410&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(new_id) {\n  const newId = new_id\n    .toLowerCase()\n    .replace(/[^\\w_.-]/g, '')\n    .replace(/[.]{2,}/g, '.')\n    .replace(/^[.]+/, '')\n    .replace(/[.]+$/, '')\n    .replace(/^$/, 'a')\n    .substring(0, 15)\n    .replace(/[.]+$/, '');\n\n  return newId.padEnd(3, newId[newId.length - 1]);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/72410"
  },
  {
    "id": "42889",
    "name": "실패율",
    "fileName": "실패율&42889&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(N, stages) {\n  let stageNFailRate = [];\n  for (let stage = 1; stage <= N; stage++) {\n    const playerReached = stages.filter((player) => player >= stage).length;\n    const playerChallenging = stages.filter(\n      (player) => player === stage\n    ).length;\n    stageNFailRate.push([stage, playerChallenging / playerReached]);\n  }\n  stageNFailRate.sort((a, b) => b[1] - a[1]);\n  return stageNFailRate.map((stage) => stage[0]);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42889"
  },
  {
    "id": "77884",
    "name": "약수의 개수와 덧셈",
    "fileName": "약수의-개수와-덧셈&77884&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(left, right) {\n  let answer = 0;\n  for (let num = left; num <= right; num++) {\n    answer = Number.isInteger(Math.sqrt(num)) ? answer - num : answer + num;\n  }\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/77884"
  },
  {
    "id": "12928",
    "name": "약수의 합",
    "fileName": "약수의-합&12928&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  let answer = 0;\n  for (let divisor = 1; divisor <= n; divisor++) {\n    if (n % divisor === 0) answer += divisor;\n  }\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12928"
  },
  {
    "id": "86051",
    "name": "없는 숫자 더하기",
    "fileName": "없는-숫자-더하기&86051&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(numbers) {\n  return 45 - numbers.reduce((a, b) => a + b);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/86051"
  },
  {
    "id": "12982",
    "name": "예산",
    "fileName": "예산&12982&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(d, budget) {\n  let answer = 0;\n  d.sort((a, b) => a - b);\n  for (const department of d) {\n    if (budget < department) break;\n    answer += 1;\n    budget -= department;\n  }\n  return answer;\n}\n\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12982"
  },
  {
    "id": "42576",
    "name": "완주하지 못한 선수",
    "fileName": "완주하지-못한-선수&42576&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(participant, completion) {\n  participant = participant.sort();\n  completion = completion.sort();\n  for (let i = 0; i < completion.length; i++) {\n    if (participant[i] !== completion[i]) return participant[i];\n  }\n  return participant[participant.length - 1];\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42576"
  },
  {
    "id": "76501",
    "name": "음양 더하기",
    "fileName": "음양-더하기&76501&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(absolutes, signs) {\n  return absolutes.reduce(\n    (acc, curr, i) => acc + curr * (signs[i] ? 1 : -1),\n    0\n  );\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/76501"
  },
  {
    "id": "12930",
    "name": "이상한 문자 만들기",
    "fileName": "이상한-문자-만들기&12930&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  return s\n    .split(\" \")\n    .map((word) =>\n      word\n        .split(\"\")\n        .map((char, index) =>\n          index % 2 === 0\n            ? word[index].toUpperCase()\n            : word[index].toLowerCase()\n        )\n        .join(\"\")\n    )\n    .join(\" \");\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12930"
  },
  {
    "id": "12931",
    "name": "자릿수 더하기",
    "fileName": "자릿수-더하기&12931&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return n\n    .toString()\n    .split(\"\")\n    .map((x) => parseInt(x))\n    .reduce((acc, curr) => acc + curr, 0);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12931"
  },
  {
    "id": "12932",
    "name": "자연수 뒤집어 배열로 만들기",
    "fileName": "자연수-뒤집어-배열로-만들기&12932&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return n\n    .toString()\n    .split(\"\")\n    .reverse()\n    .map((x) => parseInt(x));\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12932"
  },
  {
    "id": "12933",
    "name": "정수 내림차순으로 배치하기",
    "fileName": "정수-내림차순으로-배치하기&12933&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return parseInt(\n    n\n      .toString()\n      .split(\"\")\n      .sort((a, b) => b - a)\n      .join(\"\")\n  );\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12933"
  },
  {
    "id": "12934",
    "name": "정수 제곱근 판별",
    "fileName": "정수-제곱근-판별&12934&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n) {\n  return Number.isInteger(Math.sqrt(n)) ? (Math.sqrt(n) + 1) ** 2 : -1;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12934"
  },
  {
    "id": "12935",
    "name": "제일 작은 수 제거하기",
    "fileName": "제일-작은-수-제거하기&12935&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr) {\n  const index = arr.indexOf(Math.min(...arr));\n  arr.splice(index, 1);\n  return arr.length === 0 ? [-1] : arr;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12935"
  },
  {
    "id": "12969",
    "name": "직사각형 별찍기",
    "fileName": "직사각형-별찍기&12969&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - chaerin-dev\nprocess.stdin.setEncoding(\"utf8\");\nprocess.stdin.on(\"data\", (data) => {\n  const n = data.split(\" \");\n  const a = Number(n[0]),\n    b = Number(n[1]);\n  ",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12969"
  },
  {
    "id": "12937",
    "name": "짝수와 홀수",
    "fileName": "짝수와-홀수&12937&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(num) {\n  return num % 2 === 0 ? \"Even\" : \"Odd\";\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12937"
  },
  {
    "id": "42862",
    "name": "체육복",
    "fileName": "체육복&42862&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n, lost, reserve) {\n  let answer = 0;\n  let studentClothes = new Array(n + 2).fill(1);\n  for (const student of reserve) studentClothes[student] += 1;\n  for (const student of lost) studentClothes[student] -= 1;\n  for (let i = 1; i < n + 1; i++) {\n    if (studentClothes[i] === 0) {\n      if (studentClothes[i - 1] === 2 || studentClothes[i + 1] === 2) {\n        if (studentClothes[i - 1] === 2) {\n          studentClothes[i - 1] -= 1;\n          studentClothes[i] += 1;\n        } else {\n          studentClothes[i + 1] -= 1;\n          studentClothes[i] += 1;\n        }\n      }\n    }\n  }\n  for (const student of studentClothes) {\n    answer += student > 0 ? 1 : 0;\n  }\n  answer -= 2;\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42862"
  },
  {
    "id": "12940",
    "name": "최대공약수와 최소공배수",
    "fileName": "최대공약수와-최소공배수&12940&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(n, m) {\n  const gcd = greatestCommonDivisor(n, m);\n  return [gcd, (n * m) / gcd];\n}\n\nconst greatestCommonDivisor = (a, b) => {\n  if (b === 0) return a;\n  else return greatestCommonDivisor(b, a % b);\n};\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12940"
  },
  {
    "id": "86491",
    "name": "최소직사각형",
    "fileName": "최소직사각형&86491&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(sizes) {\n  const maxWidth = Math.max(...sizes.map(card => Math.min(...card)));\n  const maxHeight = Math.max(...sizes.map(card => Math.max(...card)));\n  return maxWidth * maxHeight;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/86491"
  },
  {
    "id": "12943",
    "name": "콜라츠 추측",
    "fileName": "콜라츠-추측&12943&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(num) {\n  let answer = 0;\n  while (answer <= 500) {\n    if (num === 1) return answer;\n    num = num % 2 === 0 ? num / 2 : num * 3 + 1;\n    answer += 1;\n  }\n  return -1;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12943"
  },
  {
    "id": "64061",
    "name": "크레인 인형뽑기 게임",
    "fileName": "크레인-인형뽑기-게임&64061&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(board, moves) {\n    let answer = 0;\n    const length = board.length\n    let basket = []\n    moves.forEach(move => {\n        for (let i = 0; i < length; i++) {\n            const item = board[i][move - 1]\n            if (item !== 0) {\n                if (basket[basket.length - 1] !== item) {\n                    basket.push(item)\n                } else {\n                    basket.pop()\n                    answer += 2\n                }\n                board[i][move - 1] = 0\n                break\n            }\n        }\n    })\n\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/64061"
  },
  {
    "id": "67256",
    "name": "키패드 누르기",
    "fileName": "키패드-누르기&67256&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(numbers, hand) {\n  let [l, r] = [10, 12];\n  const moveL = n => {\n    l = n;\n    return 'L';\n  };\n\n  const moveR = n => {\n    r = n;\n    return 'R';\n  };\n  return numbers\n    .map(n => {\n      if (n === 0) n = 11;\n      const to = n => {\n        const numLocation = numToLocation(n);\n        const lDistance = distanceBtwLocation(numToLocation(l), numLocation);\n        const rDistance = distanceBtwLocation(numToLocation(r), numLocation);\n        if (lDistance < rDistance) return moveL(n);\n        if (rDistance > lDistance) return moveR(n);\n        return hand === 'left' ? moveL(n) : moveR(n);\n      };\n      return num % 3 === 1 ? leftTo(num) : num % 3 === 0 ? rightTo(num) : to(num);\n    })\n    .join('');\n}\n\nfunction numToLocation(num) {\n  return [Math.floor((num - 1) / 3), (num - 1) % 3];\n}\n\nfunction distanceBtwLocation(a, b) {\n  return Math.abs(a[0] - b[0]) + Math.abs(a[1] - b[1]);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/67256"
  },
  {
    "id": "12944",
    "name": "평균 구하기",
    "fileName": "평균-구하기&12944&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr) {\n  return arr.reduce((acc, curr) => acc + curr) / arr.length;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12944"
  },
  {
    "id": "1845",
    "name": "폰켓몬",
    "fileName": "폰켓몬&1845&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(nums) {\n  const numLen = nums.length;\n  const setLen = [...new Set(nums)].length;\n  return numLen / 2 >= setLen ? setLen : numLen / 2;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/1845"
  },
  {
    "id": "12947",
    "name": "하샤드 수",
    "fileName": "하샤드-수&12947&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(x) {\n  const sum = x\n    .toString()\n    .split(\"\")\n    .map((x) => parseInt(x))\n    .reduce((acc, curr) => acc + curr);\n  return x % sum === 0;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12947"
  },
  {
    "id": "12948",
    "name": "핸드폰 번호 가리기",
    "fileName": "핸드폰-번호-가리기&12948&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(phone_number) {\n  return \"*\".repeat(phone_number.length - 4) + phone_number.slice(-4);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12948"
  },
  {
    "id": "12950",
    "name": "행렬의 덧셈",
    "fileName": "행렬의-덧셈&12950&.js",
    "level": 1,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(arr1, arr2) {\n  const answer = [];\n  arr1.forEach((row, rowIndex) => {\n    answer.push(row.map((col, colIndex) => col + arr2[rowIndex][colIndex]));\n  });\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12950"
  },
  {
    "id": "12899",
    "name": "124 나라의 숫자",
    "fileName": "124-나라의-숫자&12899&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    var answer = '';\n    const oneTwoFour = ['4', '1', '2']\n    while (n > 0) {\n        const remainder = n % 3\n        answer = oneTwoFour[remainder] + answer;\n        n = Math.floor((n - 1) / 3) //나누어떨어지지 않을 때에도 -1해도 상관없음\n    }\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12899"
  },
  {
    "id": "12900",
    "name": "2 x n 타일링",
    "fileName": "2-x-n-타일링&12900&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(n) {\n  let dp = [0, 1, 2] // n이 1, 2일때는 바로 답을 출력,\n  if (n>2){ // n이 3 이상이면 필요한 만큼의 수 까지만 수를 만들어준다.\n      for (let i=3; i<=n; i++){\n          dp.push((dp[i-1] + dp[i-2]) % 1000000007);\n      }\n  }\n  return dp[n]\n}\n/* \nn이 1일땐 1, 2일땐 2, 3일땐 3, 4일땐 5 . . 의 식이 보인다.\nn = (n - 1) + (n - 2)의 식으로 구할 수 있고,\n제한 사항을 주의해서 풀어보자. */",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12900"
  },
  {
    "id": "77885",
    "name": "2개 이하로 다른 비트",
    "fileName": "2개-이하로-다른-비트&77885&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - le2sky\nfunction solution(numbers) {\n  const answer = [];\n  numbers.forEach((num) => {\n    if (num % 2 == 0) answer.push(num + 1);\n    else {\n      let binary = [\"0\", ...num.toString(2)];\n      let last = binary.lastIndexOf(\"0\");\n      binary[last] = \"1\";\n      binary[last + 1] = \"0\";\n      answer.push(parseInt(binary.join(\"\"), 2));\n    }\n  });\n  return answer;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/77885"
  },
  {
    "id": "12902",
    "name": "3 x n 타일링",
    "fileName": "3-x-n-타일링&12902&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  if (n % 2 !== 0) return 0;\n\n  const getCount = n => {\n    const k = n / 2;\n    const count = [3, 11, ...Array(k - 2)];\n    const divider = 1000000007;\n    for (let i = 2; i < k; i++) {\n      count[i] = (4 * count[i - 1] - count[i - 2] + divider) % divider;\n    }\n    return count[count.length - 1];\n  };\n\n  return getCount(n);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12902"
  },
  {
    "id": "42747",
    "name": "H Index",
    "fileName": "H-Index&42747&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(citations) {\n    var answer = 0;\n    citations.sort((a, b) => b - a)\n    let h = 0\n    while (h + 1 <= citations[h]) h++\n    answer = h\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42747"
  },
  {
    "id": "12951",
    "name": "JadenCase 문자열 만들기",
    "fileName": "JadenCase-문자열-만들기&12951&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = ''\n    answer = s.split(' ').map(word => word.charAt(0).toUpperCase() + word.substring(1).toLowerCase()).join(' ')\n    //word[0]은 빈 문자열을 만나면 undefined를,  word.charAt(0)은 빈 문자열을 만나면 빈 문자열을 반환한다.\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12951"
  },
  {
    "id": "12952",
    "name": "N Queen",
    "fileName": "N-Queen&12952&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    /*\n    1. 0번째 행에 0번째 queen을 놓는다.\n    2. 그 다음 행의 퀸은 이전 퀸들의 범위와 겹치지 않는 곳에 놓는다. 퀸은 한 행에 반드시 하나 두어야한다.\n    3. 마지막 열까지 도달하면 성공으로 간주하고 answer에 1을 더한다.\n    4. 0번째 queen의 위치를 바꿔가며 모두 시도한다.\n    4. 단, 체스판은 일차원 배열로 선언하고 index = 행, 값 = 열 로 생각한다.\n    */\n    let answer = 0;\n    const canBePlacedOn = (chess, currentRow) => {\n        //해당 행에 둔 queen이 유효한지\n        for (let prevRow = 0; prevRow < currentRow; prevRow++) {\n            const onDiagonal = currentRow - prevRow === Math.abs(chess[currentRow] - chess[prevRow])\n            const onStraight = chess[prevRow] === chess[currentRow]\n            if (onDiagonal || onStraight) return false\n        }\n        return true\n    }\n    const placeQueen = (chess, currentRow) => {\n        //queen을 배치하다가 끝 행에 도착하면 1을 리턴, 도착하지 못하면 0을 리턴하여, 재귀적으로 모든 경우를 합하여 리턴\n        let count = 0\n        if (currentRow === chess.length) return 1\n        for (let currentQueen = 0; currentQueen < n; currentQueen++) {\n            //queen을 우선 배치한 후 가능한지 살펴본다.\n            chess[currentRow] = currentQueen\n            if (canBePlacedOn(chess, currentRow)) count += placeQueen(chess, currentRow + 1)\n        }\n        return count\n    }\n    for (let firstQueen = 0; firstQueen < n; firstQueen++) {\n        const chess = new Array(n).fill(-1)\n        chess[0] = firstQueen\n        answer += placeQueen(chess, 1)\n    }\n    return answer;\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12952"
  },
  {
    "id": "12953",
    "name": "N개의 최소공배수",
    "fileName": "N개의-최소공배수&12953&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(arr) {\n    var answer = 0;\n    answer = arr.reduce((a, b) => leastCommonMultiple(a, b), 1)\n    return answer;\n}\n\nfunction leastCommonMultiple(a, b) {\n    return a * b / greatestCommonDivisor(a, b)\n}\n\nfunction greatestCommonDivisor(a, b) {\n    while (b > 0) {\n        let r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12953"
  },
  {
    "id": "17677",
    "name": "[1차] 뉴스 클러스터링",
    "fileName": "[1차]-뉴스-클러스터링&17677&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(str1, str2) {\n    var answer = 0;\n    let compare1 = verifiedSlices(str1), compare2 = verifiedSlices(str2)\n    const union = new Set([...compare1, ...compare2])\n    let multiIntersectionLen = 0, multiUnionLen = 0\n    for (const slice of union) {\n        const compare1Count = compare1.filter(x => x === slice).length,\n            compare2Count = compare2.filter(x => x === slice).length\n        multiIntersectionLen += Math.min(compare1Count, compare2Count)\n        multiUnionLen += Math.max(compare1Count, compare2Count)\n    }\n    answer = multiUnionLen === 0 ? 65536 : Math.floor(multiIntersectionLen / multiUnionLen * 65536)\n    return answer;\n}\n\nfunction verifiedSlices(str) {\n    const onlyAlphabet = /[a-zA-Z]{2}/\n    let result = []\n    for (let i = 0; i < str.length - 1; i++) {\n        const slice = str.slice(i, i + 2)\n        if (onlyAlphabet.test(slice)) result.push(slice.toLowerCase())\n    }\n    return result\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17677"
  },
  {
    "id": "17680",
    "name": "[1차] 캐시",
    "fileName": "[1차]-캐시&17680&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(cacheSize, cities) {\n    var answer = 0;\n    let cache = []\n    if (cacheSize === 0) return 5 * cities.length\n    for (const city of cities) {\n        const cityLC = city.toLowerCase()\n        if (cache.includes(cityLC)) {\n            cache.splice(cache.indexOf(cityLC), 1)\n            cache.unshift(cityLC)\n            answer += 1\n        } else {\n            if (cache.length >= cacheSize) cache.pop()\n            cache.unshift(cityLC)\n            answer += 5\n        }\n    }\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17680"
  },
  {
    "id": "17679",
    "name": "[1차] 프렌즈4블록",
    "fileName": "[1차]-프렌즈4블록&17679&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(m, n, board) {\n  board = board.map(r => r.split(''));\n  const getSquare = ([r, c]) => [\n    [r, c],\n    [r, c + 1],\n    [r + 1, c],\n    [r + 1, c + 1],\n  ];\n\n  const isSquare = ([r, c]) => {\n    if (board[r][c] === '@') return false;\n    return [...new Set(getSquare([r, c]).map(([r, c]) => board[r][c]))].length === 1;\n  };\n\n  const remove = () => {\n    const removeArr = [];\n    for (let r = 0; r < m - 1; r++) {\n      for (let c = 0; c < n - 1; c++) {\n        if (isSquare([r, c])) getSquare([r, c]).forEach(v => removeArr.push(v));\n      }\n    }\n    removeArr.forEach(([r, c]) => {\n      board[r][c] = '@';\n    });\n    return removeArr.length !== 0;\n  };\n\n  const pull = () => {\n    for (let c = 0; c < n; c++) {\n      const remainColumn = Array.from({ length: m }, (_, r) => board[r][c]).filter(v => v !== '@');\n      const resultColumn = [...Array(m - remainColumn.length).fill('@'), ...remainColumn];\n      resultColumn.forEach((v, r) => {\n        board[r][c] = v;\n      });\n    }\n    return board;\n  };\n\n  while (remove()) {\n    pull();\n  }\n\n  return board.flat().filter(v => v === '@').length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17679"
  },
  {
    "id": "17687",
    "name": "[3차] n진수 게임",
    "fileName": "[3차]-n진수-게임&17687&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, t, m, p) {\n    let queue = [], result = [], currentNumDecimal = -1, turn = 0\n    while (result.length < t) {\n        if (queue.length === 0) {\n            currentNumDecimal++\n            currentNumDecimal.toString(n).split('').forEach(x => queue.push(x))\n        }\n        const currentChar = queue.shift()\n        if (turn % m === p - 1) result.push(currentChar)\n        turn++\n    }\n    return result.join('').toUpperCase()\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17687"
  },
  {
    "id": "17683",
    "name": "[3차] 방금그곡",
    "fileName": "[3차]-방금그곡&17683&.js",
    "level": 2,
    "code": "// https://github.com/codeisneverodd/programmers-coding-test\n// 완벽한 정답이 아닙니다.\n// 1 - minjongbaek\nfunction convertString(m) { // 문자열 m에 #이 붙은 음이 있다면 #을 제거하고 소문자로 변경한 후 반환하는 함수\n    return m\n        .replace(/C#/g, 'c')\n        .replace(/D#/g, 'd')\n        .replace(/F#/g, 'f')\n        .replace(/G#/g, 'g')\n        .replace(/A#/g, 'a');\n}\n\nfunction solution(m, musicinfos) {\n\n    // 네오가 기억하고 있는 멜로디가 라디오에서 재생됐는지 확인해야합니다.\n    // 재생시간이 길면 악보의 멜로디가 반복되어 재생되고, 짧다면 중간에 끊어지게 됩니다.\n    // #이 붙은 음은 2자리를 차지하기 때문에 #이 붙은 음을 어떻게 처리할지가 중요합니다.\n\n    const listenSound = convertString(m); // #이 붙은 음을 다른 문자로 변환합니다.\n    \n    const map = new Map(); // 조건에 일치하는 음악 정보를 저장할 map 변수를 선언합니다.\n    for (const info of musicinfos) {\n        const [start, finish, title, _score] = info.split(',');\n        // 음악 재생이 끝난 시각과 재생된 시각의 차를 구하여 재생시간을 구합니다.\n        const duration = ((Number(finish.slice(0, 2)) * 60) + (Number(finish.slice(3, 5)))) - ((Number(start.slice(0, 2)) * 60) + (Number(start.slice(3, 5))));\n        \n        const score = convertString(_score); // 악보의 멜로디에서 #이 붙은 음을 다른 문자로 변환합니다.\n\n        // 재생된 멜로디를 구합니다.\n        // 각 음이 1분에 1개씩 재생되므로, repeat() 메서드를 사용하여 재생시간을 악보의 길이로 나눈 몫 만큼 반복합니다.\n        // slice() 메서드로 재생시간을 넘어가는 멜로디는 제외합니다.\n        const playScore = score.repeat(Math.ceil(duration / score.length)).slice(0, duration);\n        if (playScore.includes(listenSound)) { // 들은 멜로디가 재생된 멜로디에 포함되어 있다면 map에 저장한다.\n            map.set(title, {score, playScore});\n        }\n    }\n    \n    // 조건에 일치하는 음악이 여러개인 경우 재생된 시간이 제일 길고 먼저 입력된 음악 제목을 반환합니다.\n    // map 객체는 삽입에 대한 순서를 기억하므로 재생된 시간이 제일 긴 음악부터 내림차순으로 정렬합니다.\n    const filter = [...map.keys()].sort((a,b) => map.get(b).playScore.length - map.get(a).playScore.length);\n    return filter.length >= 1 ? filter[0] : '(None)'; // 결과가 없다면 '(None)'을 반환하고, 그렇지 않다면 첫 번째 요소를 반환합니다.\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17683"
  },
  {
    "id": "17684",
    "name": "[3차] 압축",
    "fileName": "[3차]-압축&17684&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(msg) {\n  const outputs = [];\n  const dict = ['@', ...Array.from(Array(26), (_, i) => String.fromCharCode(65 + i))];\n  let [start, end] = [0, 1];\n\n  const doesDictHave = (start, end) => dict.includes(msg.substring(start, end));\n\n  const getInput = (start, end) => {\n    if (end + 1 > msg.length || !doesDictHave(start, end + 1)) return [start, end];\n    return getInput(start, end + 1);\n  };\n\n  const addToDict = (start, end) => {\n    if (doesDictHave(start, end)) return;\n    dict.push(msg.substring(start, end));\n  };\n\n  const addToOutputs = (start, end) => {\n    if (!doesDictHave(start, end)) return;\n    outputs.push(dict.indexOf(msg.substring(start, end)));\n  };\n\n  while (start < msg.length) {\n    [start, end] = getInput(start, end);\n    addToDict(start, end + 1);\n    addToOutputs(start, end);\n    start = end;\n  }\n  return outputs;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17684"
  },
  {
    "id": "17686",
    "name": "[3차] 파일명 정렬",
    "fileName": "[3차]-파일명-정렬&17686&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(files) {\n    var answer = [];\n    const numberRegex = /[0-9]+/\n    answer = files.sort((a, b) => {\n        const [matchA, matchB] = [a.match(numberRegex), b.match(numberRegex)]\n        const [headA, headB] = [a.slice(0, matchA.index).toLowerCase(), b.slice(0, matchB.index).toLowerCase()]\n        const [numberA, numberB] = [parseInt(matchA[0]), parseInt(matchB[0])]\n        return headA < headB ? -1 : headA > headB ? 1 : numberA < numberB ? -1 : numberA > numberB ? 1 : 0\n    })\n    return answer;\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/17686"
  },
  {
    "id": "92335",
    "name": "k진수에서 소수 개수 구하기",
    "fileName": "k진수에서-소수-개수-구하기&92335&.js",
    "level": 2,
    "code": "// https://github.com/codeisneverodd/programmers-coding-test\n// 완벽한 정답이 아닙니다.\n// 1 - minjongbaek\nfunction isPrime(number) { // 소수를 판별하는 함수\n    if (number < 2) return false;\n    for (let i = 2; i * i <= number; i += 1) {\n        if (number % i === 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\nfunction solution(n, k) {\n    // 문제를 얼핏 보면 4가지의 경우를 모두 생각해야할 것 같지만,\n    // 결국은 앞이나 뒤에 0이 하나라도 있거나 아예 없는 경우에 소수인지 확인하면 됩니다.\n    // 따라서 k진수로 변환 후 0을 기준으로 나누고 각 요소가 소수인지 판별하면 됩니다.\n\n    // (n).toString(k) // n을 k진수로 변환합니다.\n    // .split('0') // 0을 기준으로 나눕니다.\n    // .filter((number) => isPrime(+number)).length // 소수가 아닌 요소를 걸러낸 후에 개수를 셉니다.\n    return (n).toString(k).split('0').filter((number) => isPrime(+number)).length;\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/92335"
  },
  {
    "id": "87390",
    "name": "n^2 배열 자르기",
    "fileName": "n^2-배열-자르기&87390&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution (n, left, right) {\n  const answer = [];\n  \n  for (let i=left; i <= right; i++) { // left부터 right까지를 구한다.\n      let row = parseInt(i/n);\t// 행(row)을 구한다.\n      let column = i%n;\t// 열(column)을 구한다.\n      answer.push(Math.max(row, column) + 1) // 행과 열중 큰 값을 푸시한다.\n  }\n  return answer\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/87390"
  },
  {
    "id": "42746",
    "name": "가장 큰 수",
    "fileName": "가장-큰-수&42746&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n    var answer = '';\n    numbers.sort(sortFunc)\n    answer = numbers.join('')\n    if (answer[0] === '0') return '0'\n    return answer;\n}\n\nconst sortFunc = (a, b) => {\n    const compareA = parseInt(a.toString() + b.toString())\n    const compareB = parseInt(b.toString() + a.toString())\n    return compareB - compareA\n}\n\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42746"
  },
  {
    "id": "12905",
    "name": "가장 큰 정사각형 찾기",
    "fileName": "가장-큰-정사각형-찾기&12905&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(board) {\n    for (let row = 0; row < board.length; row++) {//해당 칸이 0이 아니고 위, 왼쪽 대각선, 왼쪽이 정사각형이면, 정사각형 연장가능\n        for (let col = 0; col < board[0].length; col++) {\n            if (board[row][col] >= 1 && (!(board[row - 1] === undefined || board[row][col - 1] === undefined)))\n                board[row][col] = Math.min(board[row - 1][col], board[row - 1][col - 1], board[row][col - 1]) + 1;\n        }\n    }\n    return Math.max(...board.map((row) => Math.max(...row))) ** 2; //수정된 board 내의 최댓값이 가능한 정사각형의 최대\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12905"
  },
  {
    "id": "81302",
    "name": "거리두기 확인하기",
    "fileName": "거리두기-확인하기&81302&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(places) {\n    var answer = [];\n    answer = places.map(place => {\n        return place.some((row, rowIndex) =>\n            row.split('').some((mark, colIndex, rowArr) => {\n                if (mark === 'X') return false\n                const countPeopleAround = [\n                    rowArr[colIndex - 1] || '',\n                    rowArr[colIndex + 1] || '',\n                    (place[rowIndex - 1] || '')[colIndex],\n                    (place[rowIndex + 1] || '')[colIndex],\n                ].filter(mark => mark === 'P').length\n                return (mark === 'P' && countPeopleAround > 0) || (mark === 'O' && countPeopleAround > 1)\n            })\n        ) ? 0 : 1\n    })\n    return answer;\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/81302"
  },
  {
    "id": "1844",
    "name": "게임 맵 최단거리",
    "fileName": "게임-맵-최단거리&1844&.js",
    "level": 2,
    "code": "// https://github.com/codeisneverodd/programmers-coding-test\n// 1 - prove-ability\nfunction solution(maps) {\n    // BFS 활용\n    const row = maps.length - 1, col = maps[0].length - 1;\n    \n    // 큐 - 시작 위치 y, x, 이동 거리\n    const queue = [[0, 0, 1]];\n    \n    while(queue.length) {\n        // 큐 추출\n        let [y, x, count] = queue.shift();\n        // 상대 팀 진영이라면\n        if(y === row && x === col) return count;\n        // 동서남북 확인\n        for(let i = 0; i < 4; i++) {\n            const [dy, dx] = DIRECTION[i];\n            // 다음 길 위치\n            const nextY = dy + y, nextX = dx + x;\n            // 맵 밖으로 나간다면\n            if(isOut(nextY, nextX, row, col)) continue;\n            // 도착한 곳이 벽이라면\n            if(maps[nextY][nextX] === 0) continue;\n            // 이미 지난 곳 벽으로 만들어서 다음에 접근 방지\n            maps[nextY][nextX] = 0;\n            // 다음에 확인해야하는 곳 큐에 추가\n            // 갈수 있는 곳이 두 곳이라면 두 곳 추가됨       \n            queue.push([nextY, nextX, count + 1]);\n            // 처음에 count 를 let 으로 선언하고 ++count 로 작성했을 떄 에러 발생 - 이유는 모르겠음..\n        }\n    }\n    \n    return -1;\n}\n\n// 상 우 하 좌\nconst DIRECTION = [[1, 0], [0, 1], [-1, 0], [0, -1]];\n\n// 사용이 가능한 길인지 확인하는 함수\nconst isOut = (nextY, nextX, row, col) => nextY < 0 || nextX < 0 || nextY > row || nextX > col;",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/1844"
  },
  {
    "id": "60058",
    "name": "괄호 변환",
    "fileName": "괄호-변환&60058&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(p) {\n    if (p.length === 0) return p\n    let bracketCount = 0\n    let isURight = true\n    for (let i = 0; i < p.length; i++) {\n        bracketCount = p[i] === '(' ? bracketCount + 1 : bracketCount - 1\n        if (bracketCount < 0) isURight = false\n        if (bracketCount === 0) {\n            const [u, v] = [p.slice(0, i + 1), p.slice(i + 1)]\n            if (isURight) {\n                return u + solution(v)\n            } else {\n                let emptyString = '(' + solution(v) + ')'\n                const slicedReversedString = u\n                    .slice(1, u.length - 1)\n                    .split('')\n                    .map(bracket => bracket === '(' ? ')' : '(')\n                    .join('')\n                return emptyString + slicedReversedString\n            }\n        }\n    }\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/60058"
  },
  {
    "id": "76502",
    "name": "괄호 회전하기",
    "fileName": "괄호-회전하기&76502&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    let answer = 0;\n    let sArr = s.split('')\n    if (isRight(sArr.join(''))) answer += 1\n    for (let i = 0; i < sArr.length - 1; i++) {\n        sArr.push(sArr.shift())\n        if (isRight(sArr.join(''))) answer += 1\n    }\n    return answer;\n}\n\nfunction isRight(str) {\n    const bracketOpen = ['[', '{', '('], bracketClose = [']', '}', ')']\n    let status = [{open: false, openOrder: []}, {open: false, openOrder: []}, {open: false, openOrder: []}]\n    for (let sIndex = 0; sIndex < str.length; sIndex++) {\n        for (let bIndex = 0; bIndex < 3; bIndex++) {\n            if (str[sIndex] === bracketOpen[bIndex]) {\n                status[bIndex].open = true\n                status[bIndex].openOrder.push(sIndex)\n            }\n            if (str[sIndex] === bracketClose[bIndex]) {\n                if (status[bIndex].openOrder.length > 0) {\n                    if (status.filter(check => check.open && check.openOrder[check.openOrder.length - 1] > status[bIndex].openOrder[status[bIndex].openOrder.length - 1]).length > 0)\n                        return false //먼저 닫혀야 하는 괄호보다 먼저 닫힘\n                    status[bIndex].openOrder.pop()\n                    status[bIndex].open = false\n                } else {\n                    return false //열리기 전에 닫힘\n                }\n            }\n        }\n    }\n    for (let i = 0; i < 3; i++) if (status[i].open) return false //닫히지 않은 괄호가 있음\n    return true\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/76502"
  },
  {
    "id": "87377",
    "name": "교점에 별 만들기",
    "fileName": "교점에-별-만들기&87377&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(line) {\n  const getCrossPoint = ([A, B, E], [C, D, F]) => {\n    if (A * D - B * C === 0) return [Infinity, Infinity];\n    return [(B * F - E * D) / (A * D - B * C), (E * C - A * F) / (A * D - B * C)];\n  }; //문제 설명 최하단 참조\n\n  const crossPoints = line.flatMap((lineA, i) =>\n    line\n      .slice(i + 1)\n      .map(lineB => getCrossPoint(lineA, lineB))\n      .filter(([x, y]) => Number.isInteger(x) && Number.isInteger(y))\n  );\n\n  const generateCanvas = crossPoints => {\n    const xPoints = [...crossPoints.map(([x, y]) => x)];\n    const yPoints = [...crossPoints.map(([x, y]) => y)];\n    const [minX, maxX] = [Math.min(...xPoints), Math.max(...xPoints)];\n    const [minY, maxY] = [Math.min(...yPoints), Math.max(...yPoints)];\n    const xLength = Math.abs(maxX - minX) + 1;\n    const yLength = Math.abs(maxY - minY) + 1;\n\n    return {\n      canvas: Array.from({ length: yLength }, () => Array(xLength).fill('.')),\n      draw([x, y], value) {\n        this.canvas[Math.abs(y - maxY)][Math.abs(x - minX)] = value;\n      },\n      print() {\n        return this.canvas.map(row => row.join(''));\n      },\n    };\n  };\n\n  const canvas = generateCanvas(crossPoints);\n\n  crossPoints.forEach(point => {\n    canvas.draw(point, '*');\n  });\n\n  return canvas.print();\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/87377"
  },
  {
    "id": "42885",
    "name": "구명보트",
    "fileName": "구명보트&42885&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(people, limit) {\n  let cnt = 0;\n  \n  people.sort((a, b) => {return a - b}) // 몸무게 오름차순\n  \n  while(people.length != 0){ // 무인도에 갖힌 사람이 없어질때까지 반복 \n      if (people[0] + people[people.length-1] <= limit){ // 무게가 되면 둘 다 빼주기\n          people.pop()\n          people.shift()\n      } else {\n          people.pop() // 무거운사람을 뺴주자\n      }\n      cnt++;\n  }\n  return cnt;\n} // 4주차 2번 문제와 유사함\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42885"
  },
  {
    "id": "42586",
    "name": "기능개발",
    "fileName": "기능개발&42586&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd - 시간복잡도 감소\nfunction solution(progresses, speeds) {\n    var answer = [];\n    const remainDays = progresses.map((prog, index) => Math.ceil((100 - prog) / speeds[index]))\n    console.log(remainDays)\n    let maxDay = remainDays[0]\n    answer.push(0)\n    for (let i = 0; i < remainDays.length; i++) {\n        if (remainDays[i] <= maxDay) {\n            answer[answer.length - 1] += 1\n        } else {\n            answer.push(1)\n            maxDay = remainDays[i]\n        }\n    }\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42586"
  },
  {
    "id": "42583",
    "name": "다리를 지나는 트럭",
    "fileName": "다리를-지나는-트럭&42583&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(bridge_length, weight, truck_weights) {\n    let [tick, onBridge, weightOnBridge] = [0, [{weight: 0, timeToOut: 0}], 0]\n    while (onBridge.length > 0 || truck_weights.length > 0) {\n        if (onBridge[0].timeToOut === tick) weightOnBridge -= onBridge.shift().weight\n        if (weightOnBridge + truck_weights[0] <= weight) {\n            weightOnBridge += truck_weights[0]\n            onBridge.push({weight: truck_weights.shift(), timeToOut: tick + bridge_length})\n        } else {\n            if (onBridge[0]) tick = onBridge[0].timeToOut - 1 // 시간을 줄이는 포인트\n        }\n        tick++\n    }\n    return tick\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42583"
  },
  {
    "id": "12911",
    "name": "다음 큰 숫자",
    "fileName": "다음-큰-숫자&12911&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    let answer = n;\n    const nCountOne = n.toString(2).match(/1/g).length\n    while (true) {\n        answer++\n        if (nCountOne === (answer).toString(2).match(/1/g).length) break\n    }\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12911"
  },
  {
    "id": "118667",
    "name": "두 큐 합 같게 만들기",
    "fileName": "두-큐-합-같게-만들기&118667&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(queue1, queue2) {\n  const getSum = arr => arr.reduce((a, c) => a + c, 0);\n\n  if (getSum([...queue1, ...queue2]) % 2 !== 0) return -1;\n\n  const queue = [...queue1, ...queue2, ...queue1, ...queue2];\n  const maxCount = queue.length;\n  const average = getSum(queue) / 4;\n  let [currentSum, count, start, end] = [getSum(queue1), 0, 0, queue1.length];\n\n  const pop = () => {\n    currentSum -= queue[start];\n    start += 1;\n    count += 1;\n  };\n  const insert = () => {\n    currentSum += queue[end];\n    end += 1;\n    count += 1;\n  };\n\n  while (count <= maxCount) {\n    if (currentSum < average) insert();\n    if (currentSum > average) pop();\n    if (currentSum === average) return count;\n  }\n  return -1;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/118667"
  },
  {
    "id": "12913",
    "name": "땅따먹기",
    "fileName": "땅따먹기&12913&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(land) {\n  var answer = 0;\n  \n  for (i = 1; i < land.length; i++){\n      land[i][0] += (Math.max(land[i-1][1], land[i-1][2], land[i-1][3]));\n      land[i][1] += (Math.max(land[i-1][0], land[i-1][2], land[i-1][3]));\n      land[i][2] += (Math.max(land[i-1][0], land[i-1][1], land[i-1][3]));\n      land[i][3] += (Math.max(land[i-1][0], land[i-1][1], land[i-1][2]))\n  }\n  answer = land[land.length - 1]\n  return Math.max(...answer)\n}\n/* 풀이 과정\n1. land의 행만큼 반복문을 돌린다.\n2. i행(두번째 행)부터 land.length - 1행(마지막 행)까지 본인 열을 제외한 나머지 열의 최댓값을 본인의 열에 더하여 누적한다.\n3. 마지막까지 다 구하면 마지막 행에서 최대값을 반환한다.*/\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12913"
  },
  {
    "id": "12914",
    "name": "멀리 뛰기",
    "fileName": "멀리-뛰기&12914&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  if (n < 2) return 1;\n  const count = [0, 1, 2, ...Array(n - 2).fill(0)];\n  count.forEach((_, i) => {\n    if (i > 2) count[i] = (count[i - 2] + count[i - 1]) % 1234567;\n  });\n  return count[n];\n}\n//재귀를 사용하면 콜스택 오버플로우가 발생합니다.\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12914"
  },
  {
    "id": "62048",
    "name": "멀쩡한 사각형",
    "fileName": "멀쩡한-사각형&62048&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(w, h) {\n    var answer = 1;\n    const gcd = greatestCommonDivisor(w, h)\n    answer = w * h - (h + w - gcd)\n    return answer;\n}\n\nlet greatestCommonDivisor = (a, b) => {\n    while (b > 0) {\n        let r = a % b;\n        a = b;\n        b = r;\n    }\n    return a;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/62048"
  },
  {
    "id": "72411",
    "name": "메뉴 리뉴얼",
    "fileName": "메뉴-리뉴얼&72411&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(orders, course) {\n    var answer = [];\n    for (const selectNum of course) {\n        let combinations = []\n        for (const order of orders) {\n            getCombinations(Array.from(order), selectNum)\n                .map(combination => combination.sort().join(''))// 'WX'는 'XW'와 같아야한다.\n                .forEach(combString => combinations.push(combString))\n        }\n        const combCounts = combinations.reduce((counts, combination) => {\n            counts[combination] = (counts[combination] || 0) + 1;\n            return counts;\n        }, {});\n        let maxCount = 0, maxComb = []\n        for (const comb in combCounts) if (combCounts[comb] >= maxCount) maxCount = combCounts[comb]\n        for (const comb in combCounts) if (combCounts[comb] === maxCount && maxCount >= 2) maxComb.push(comb)\n        answer.push(...maxComb)\n    }\n    answer = answer.sort()\n    return answer;\n}\n\nconst getCombinations = (array, selectNum) => {\n    const result = [];\n    if (selectNum === 1) return array.map((element) => [element]);\n    array.forEach((fixed, index, origin) => {\n        const restCombinations = getCombinations(origin.slice(index + 1), selectNum - 1);\n        const attached = restCombinations.map((restCombination) => [fixed, ...restCombination]);\n        result.push(...attached);\n    });\n    return result;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/72411"
  },
  {
    "id": "84512",
    "name": "모음사전",
    "fileName": "모음사전&84512&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(word) {\n  const alphabetRank = { A: 0, E: 1, I: 2, O: 3, U: 4 };\n  const price = calculatePrice([1], 5);\n  return word\n    .split(\"\")\n    .map((alphabet, index) => 1 + price[index] * alphabetRank[alphabet])\n    .reduce((acc, curr) => acc + curr, 0);\n}\nconst calculatePrice = (result = [1], targetLength) => {\n  if (result.length === targetLength) return result;\n  return calculatePrice([result[0] * 5 + 1, ...result], targetLength);\n};\n/*\n각 자리 문자를 바로 다음 문자로 바꾸는 데에 얼마의 비용이 들까?\n4번째 자리  - 1\n3번째 자리  - 1*5 + 1 = 6\n2번째 자리  - 6*5 + 1 = 31\n1번째 자리  - 31*5 + 1 = 156\n0번째 자리  - 156*5 + 1 = 781\n\n검증(1부터 시작하므로 1 + 비용)\nI => (1 + 781 * 2) = 1563\nEIO => (1 + 781 * 1) + (1 + 156 * 2) + (1 + 31 * 3) = 1189\nAAAE => 1 + 1 + 1 + (1 + 6 * 1) = 10\nAAAAE => 1 + 1 + 1 + 1 + (1 + 1*1) = 6\n추천 레퍼런스: https://seongho96.tistory.com/50\n*/\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/84512"
  },
  {
    "id": "60057",
    "name": "문자열 압축",
    "fileName": "문자열-압축&60057&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = 0;\n    let lengthArr = []\n    for (let i = 1; i <= s.length; i++) lengthArr.push(compressedString(s, i).length)\n    answer = Math.min(...lengthArr)\n    return answer;\n}\n\nfunction compressedString(str, unitNum) {\n    let count = 1\n    let result = ['']\n    for (let repeat = 0; repeat <= str.length / unitNum; repeat++) {\n        const slicedGroup = str.slice(unitNum * repeat, unitNum * repeat + unitNum)\n        if (result[result.length - 1] === slicedGroup) {\n            count++\n        } else {\n            if (count > 1) result[result.length - 1] = count + result[result.length - 1]\n            result.push(slicedGroup)\n            count = 1\n        }\n    }\n    return result.join('')\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/60057"
  },
  {
    "id": "49994",
    "name": "방문 길이",
    "fileName": "방문-길이&49994&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(dirs) {\n  const move = ([x, y], dir) => {\n    let next = [x, y];\n    if (dir === 'U') next = [x, y + 1];\n    if (dir === 'D') next = [x, y - 1];\n    if (dir === 'R') next = [x + 1, y];\n    if (dir === 'L') next = [x - 1, y];\n    if (Math.abs(next[0]) > 5 || Math.abs(next[1]) > 5) return [x, y];\n    return next;\n  };\n\n  const isSameRoute = ([s1, e1], [s2, e2]) => {\n    const isSamePoint = ([x1, y1], [x2, y2]) => x1 === x2 && y1 === y2;\n    return (isSamePoint(s1, s2) && isSamePoint(e1, e2)) || (isSamePoint(s1, e2) && isSamePoint(s2, e1));\n  };\n\n  const trace = {\n    visited: [],\n    visit(start, end) {\n      if (start[0] === end[0] && start[1] === end[1]) return;\n      if (!this.visited.find(route => isSameRoute(route, [start, end]))) this.visited.push([start, end]);\n    },\n  };\n\n  let current = [0, 0];\n\n  dirs.split('').forEach(dir => {\n    const next = move(current, dir);\n    trace.visit(current, next);\n    current = next;\n  });\n\n  return trace.visited.length;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/49994"
  },
  {
    "id": "12978",
    "name": "배달",
    "fileName": "배달&12978&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n\n// 1 - pereng11\n// 다익스트라 + 최소힙 O( N * logN ) \n    // [목적지, 거리] 노드를 값으로 가지는, 거리에 대한 최소힙 \nclass MinHeap{\n    constructor ()\n    {\n      this.heap = [ null ];\n    }\n    // 맨 끝에 노드를 삽입 후 위로 올라가면서 정렬\n    push ( val )\n    {\n          this.heap.push(val);\n          let childIdx = this.heap.length-1;\n          let parentIdx = Math.floor(childIdx / 2);\n          while(parentIdx > 0 && this.heap[parentIdx][1] > this.heap[childIdx][1]){\n            this.swap( childIdx, parentIdx );\n            childIdx = parentIdx;\n            parentIdx = Math.floor(childIdx / 2);\n          }\n    }\n    pop ()\n    {\n      if ( this.heap.length === 1 )\n      {\n        return undefined;\n      }\n      // 최소값은 빼두었다가 리턴하고, 가장 끝 값을 맨 위로 가져와 아래로 내려가면서 정렬\n      const minNode = this.heap[ 1 ];\n      this.heap[ 1 ] = this.heap[ this.heap.length - 1 ];\n      this.heap.pop();\n      let parentIdx = 1;\n      let leftChildIdx = 2;\n      let rightChildIdx = 3;\n      while ( parentIdx < this.heap.length )\n      {\n        // 자식이 없는 경우 \n        if ( !this.heap[ leftChildIdx ] )\n        {\n          break;\n        } // 왼쪽 자식만 있는 경우\n        else if ( !this.heap[ rightChildIdx ] )\n        {\n          if ( this.heap[ parentIdx ][ 1 ] > this.heap[ leftChildIdx ][ 1 ] )\n          {\n            this.swap( parentIdx, leftChildIdx );\n          }\n          break;\n          // 둘 중 하나가 부모보다 작을 때, 더 작은 쪽으로 정렬\n        } else if ( this.heap[ parentIdx ][ 1 ] > this.heap[ leftChildIdx ][ 1 ] || this.heap[ parentIdx ][ 1 ] > this.heap[ rightChildIdx ][ 1 ] )\n        {\n          const minChildIdx = this.heap[ leftChildIdx ][ 1 ] < this.heap[ rightChildIdx ][ 1 ] ? leftChildIdx : rightChildIdx;\n          this.swap( parentIdx, minChildIdx );\n          parentIdx = minChildIdx;\n          leftChildIdx = parentIdx * 2\n          rightChildIdx = parentIdx * 2 + 1;\n        } else\n        {\n          // 끝까지 내려가지 않았더라도 부모가 가장 작으면 정렬 중지\n          break;\n        }\n      }\n      return minNode;\n    }\n    swap ( idx1, idx2 )\n    {\n        [ this.heap[ idx1 ], this.heap[ idx2 ] ] = [ this.heap[ idx2 ], this.heap[ idx1 ] ];\n    }\n    length ()\n    {\n      return this.heap.length;\n    }\n}\n  \nfunction solution ( N, road, K )\n{\n  const roadsTable = {}; //전체 도로 정보\n  \n  // 도로 정보 초기화 roadTable[시작점] = [목적지, 거리] 배열\n  for ( let i = 1; i <= N; i++ )\n  {\n    roadsTable[ i ] = [];\n  }\n  road.forEach( road =>\n  {\n    let [ sp, ep, dist ] = road;\n    roadsTable[ sp ].push( [ ep, dist ] );\n    roadsTable[ ep ].push( [ sp, dist ] );\n  } );\n\n  function djikstra ( sp )\n  {\n    const visited = new Array( N + 1 ).fill( false ); //방문 확인 배열\n    const dist = new Array( N + 1 ).fill( Infinity ); //목표지점까지 거리\n    const heap = new MinHeap();\n\n    //시작점 삽입\n    heap.push( [sp, 0] );\n\n    // 가장 가까운 목적지부터 순서대로 방문\n    while ( heap.length() > 1 )\n    {\n      //힙에 저장된 목적지 중 가장 가까운 거리의 목적지를 꺼냄 [목적지, 거리]\n      const [ ep, val ] = heap.pop();\n      //아직 방문하지 않은 곳만 처리\n      if ( !visited[ ep ] )\n      {\n        //방문처리, 거리 저장\n        visited[ ep ] = true;\n        dist[ ep ] = val;\n        //방문 지점을 거쳐서 가는 다른 목적지 구하기\n        const nexts = roadsTable[ ep ];\n        if ( nexts )\n        {\n          nexts.forEach( n =>\n          {\n            let [ nextEp, nextVal ] = n;\n            if ( !visited[ nextEp ] ) //아직 방문하지 않은 곳일 경우, '지금까지의 거리 + 현재 위치에서의 거리'로 힙에 삽입\n            {\n              heap.push( [ nextEp, val + nextVal ] );\n            }\n          })\n        }\n      }\n    }\n    // 거리가 K이하인 지점의 개수 반환\n    const result = dist.filter( d => d <= K ).length;\n    return result;\n  }\n  \n  const answer = djikstra( 1 );\n  return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12978"
  },
  {
    "id": "86052",
    "name": "빛의 경로 사이클",
    "fileName": "빛의-경로-사이클&86052&.js",
    "level": 2,
    "code": "// https://github.com/codeisneverodd/programmers-coding-test\n// 완벽한 정답이 아닙니다.\n// 1 - minjongbaek\n\n// 빛의 이동을 위한 DX, DY 변수를 선언합니다.\nconst DX = [-1, 1, 0, 0];\nconst DY = [0, 0, -1, 1];\n\nfunction solution(grid) {\n\n    // DFS에 4방향을 고려하여 문제를 풉니다.\n    // 핵심은 이미 방문한 칸이고 방향이 동일하다면 하나의 사이클이 형성된 것으로 생각해야합니다.\n\n    const answer = [];\n\n    // visited 변수를 선언 후 방문 여부를 확인할 3차원 배열을 할당합니다. [x좌표, y좌표, [하, 상, 좌, 우]]\n    const visited = Array.from({ length: grid.length }, () => []).map((v) => {\n        for (let i = 0; i < grid[0].length; i += 1) {\n            v.push(new Array(4).fill(false));\n        }\n        return v\n    });\n\n    for (let x = 0; x < grid.length; x += 1) {\n        for (let y = 0; y < grid[0].length; y += 1) {\n            for (let d = 0; d < 4; d += 1) {\n                // x, y 좌표에 하, 상, 좌, 우 방향으로 방문한 적이 없다면 dfs를 수행합니다.\n                if (!visited[x][y][d]) {\n                    const stack = [];\n                    stack.push([x, y, d]);\n\n                    let cnt = 0;\n                    while (stack.length !== 0) {\n                        const [currentX, currentY, currentD] = stack.pop();\n                        if (!visited[currentX][currentY][currentD]) {\n                            visited[currentX][currentY][currentD] = true;\n                            cnt += 1;\n\n                            const [nextX, nextY] = getNextXY(currentX, currentY, currentD, grid.length, grid[0].length); // 다음으로 이동할 좌표를 구합니다.\n                            const nextD = getNextD(grid[nextX][nextY], currentD) // x, y 칸에 적혀있는 문자열대로 방향을 다음 방향을 구합니다.\n                            \n                            stack.push([nextX, nextY, nextD])\n                        }\n\n                    }\n                    answer.push(cnt);\n                }\n            }\n        }\n    }\n    return answer.sort((a, b) => a - b);\n}\n\n// 다음 행선지를 구하는 함수\nfunction getNextXY(x, y, d, xLength, yLength) {\n    x += DX[d];\n    y += DY[d];\n\n    // x나 y의 값이 유효하지 않은 경우 값을 재할당합니다.\n    if (x < 0) x = xLength - 1;\n    if (x >= xLength) x = 0;\n    if (y < 0) y = yLength - 1;\n    if (y >= yLength) y = 0;\n\n    return [x, y];\n}\n\n// 현재 방향과 칸에 표시된 문자를 기준으로 다음 행선지의 방향을 구하는 함수\nfunction getNextD(command, d) {\n    if (command === 'L') {\n        d = [2, 3, 1, 0][d]\n    } else if (command === 'R') {\n        d = [3, 2, 0, 1][d]\n    }\n    return d\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/86052"
  },
  {
    "id": "68645",
    "name": "삼각 달팽이",
    "fileName": "삼각-달팽이&68645&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  const snail = Array.from(Array(n), (_, index) => Array(index + 1));\n  let currentNum = 0;\n  let [currentRow, currentCol] = [-1, 0];\n  let shouldMove = n;\n  while (shouldMove > 0) {\n    for (let i = 0; i < shouldMove; i++)\n      snail[++currentRow][currentCol] = ++currentNum;\n    for (let i = 0; i < shouldMove - 1; i++)\n      snail[currentRow][++currentCol] = ++currentNum;\n    for (let i = 0; i < shouldMove - 2; i++)\n      snail[--currentRow][--currentCol] = ++currentNum;\n    shouldMove -= 3;\n  }\n  return snail.flatMap((num) => num);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/68645"
  },
  {
    "id": "42839",
    "name": "소수 찾기",
    "fileName": "소수-찾기&42839&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(numbers) {\n    var answer = 0;\n    const numArr = numbers.split('')\n    const permutationAll = []\n    for (let r = 1; r <= numbers.length; r++) {\n        const permutationR\n            = Permutation(numArr, r).map((permuArr) =>\n            parseInt(permuArr.join(''))\n        )\n        for (let i = 0; i < permutationR.length; i++) permutationAll.push(permutationR[i])\n    }\n    const permutationSet = [...new Set(permutationAll)]\n    for (const number of permutationSet) answer += isPrime(number) ? 1 : 0\n    return answer;\n}\n\nfunction Permutation(arr, r) {\n    const result = []\n    if (r === 1) return arr.map((num) => [num])\n    arr.forEach((fixed, index, org) => {\n        const rest = [...org.slice(0, index), ...org.slice(index + 1)]\n        const permutation = Permutation(rest, r - 1)\n        const attached = permutation.map((numbers) => [fixed, ...numbers])\n        result.push(...attached)\n    })\n    return result\n}\n\nfunction isPrime(num) {\n    for (let i = 2; i <= Math.sqrt(num); i++) if (num % i === 0) return false\n    return num >= 2\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42839"
  },
  {
    "id": "67257",
    "name": "수식 최대화",
    "fileName": "수식-최대화&67257&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(expression) {\n    var answer = 0;\n    const mathExp = ['*', '+', '-']\n    let priorityArr = Permutation(mathExp, 3)\n    const calculated = []\n    for (const priority of priorityArr) {\n        const expressionArr = expression.split(/(\\D)/)\n        for (const exp of priority) {\n            while (expressionArr.includes(exp)) {\n                const index = expressionArr.indexOf(exp)\n                expressionArr.splice(index - 1, 3, eval(expressionArr.slice(index - 1, index + 2).join('')))\n            }\n        }\n        calculated.push(Math.abs(expressionArr[0]))\n    }\n    answer = Math.max(...calculated)\n    return answer\n}\n\nfunction Permutation(arr, r) {\n    const result = []\n    if (r === 1) return arr.map((num) => [num])\n    arr.forEach((fixed, index, org) => {\n        const rest = [...org.slice(0, index), ...org.slice(index + 1)]\n        const permutation = Permutation(rest, r - 1)\n        const attached = permutation.map((numbers) => [fixed, ...numbers])\n        result.push(...attached)\n    })\n    return result\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/67257"
  },
  {
    "id": "72412",
    "name": "순위 검색",
    "fileName": "순위-검색&72412&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(infos, queries) {\n  const infoData = {};\n\n  const fetchInfoData = (keyArr, score, start) => {\n    const key = keyArr.join('');\n\n    infoData[key] ? infoData[key].push(score) : (infoData[key] = [score]);\n\n    for (let i = start; i < keyArr.length; i++) {\n      fetchInfoData(\n        keyArr.map((v, index) => (index === i ? '-' : v)),\n        score,\n        i + 1\n      );\n    }\n  };\n\n  const getPassCount = (key, passScore) => {\n    const scores = infoData[key];\n\n    if (!scores) return 0;\n\n    let [left, right] = [0, scores.length];\n\n    while (left < right) {\n      const mid = Math.floor((left + right) / 2);\n      scores[mid] >= passScore ? (right = mid) : (left = mid + 1);\n    }\n\n    return scores.length - left;\n  };\n\n  infos\n    .map(info => [info.split(' ').slice(0, 4), info.split(' ')[4]])\n    .forEach(([keyArr, score]) => fetchInfoData(keyArr, +score, 0));\n\n  Object.keys(infoData).forEach(key => {\n    infoData[key].sort((a, b) => a - b);\n  });\n\n  return queries\n    .map(query => query.replace(/ and /g, '').split(' '))\n    .map(([key, passScore]) => getPassCount(key, +passScore));\n}\n// 주의 할 점\n// 1. 중첩 구조에 있는 객체를 수정할 때 새로운 객체를 만들어 재할당하면 효율성에 걸림\n// 2. 고차함수 중첩하면 새로운 객체를 만드는 행위가 너무 많음으로 효율성에 걸림.\n// 3. filter 대신 정렬 후 이진 탐색을 활용해야 효율성에 걸리지 않음.\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/72412"
  },
  {
    "id": "12923",
    "name": "숫자 블록",
    "fileName": "숫자-블록&12923&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - iHoHyeon\nfunction solution(begin, end) {\n  return new Array(end - begin + 1).fill(null).map((v, idx) => calc(begin + idx));\n  // begin ~ end 각 위치에 대해서 calc 함수의 return 값으로 채운다.\n}\n  \nconst calc = (number) => {\n  if (number === 1) return 0;\n  // 1번째 위치는 무조건 0블록이 위치\n\n  for (let i = 2; i <= Math.sqrt(number); i++) {\n    if (number % i === 0 && number / i <= 10_000_000) return number / i;\n    // 10_000_000번 블록까지만 놓았으므로 숫자를 초과하는 경우는 제외\n  }\n\n  return 1;\n};\n\n/*\n    1번 블록부터 10_000_000번 블록까지 전부 규칙에 따라서 놓는 경우는\n    시간 / 공간 복잡도가 급상승\n\n    -> 따라서 각 위치에 어떤 숫자의 블록이 놓일지를 계산해주자\n    \n    -> n번째 위치에는 1, n을 제외한 n의 가장 큰 약수의 블록이 놓이게 된다.\n\n    -> 가장 큰 약수는 n / (n의 가장 작은 약수)임을 이용해서 계산해주면 된다.\n\n    + 가장 큰 약수가 1인 경우는 소수인 경우이고 숫자 1 블록이 놓인다.\n*/\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12923"
  },
  {
    "id": "12924",
    "name": "숫자의 표현",
    "fileName": "숫자의-표현&12924&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) { //수학적 풀이는 별도로 하지 않았습니다.\n    var answer = 0;\n    for (let i = 1; i <= n; i++) {\n        let sum = 0\n        for (let j = i; j <= n; j++) {\n            sum += j\n            if (sum >= n) {\n                if (sum === n) answer++\n                break\n            }\n        }\n    }\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12924"
  },
  {
    "id": "49993",
    "name": "스킬트리",
    "fileName": "스킬트리&49993&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(skill, skill_trees) {\n    var answer = 0;\n    for (const tree of skill_trees) {\n        let check = Array.from(tree).filter(x => skill.includes(x)).map(x => skill.indexOf(x))\n        if (checkOrder(check)) answer += 1\n    }\n    return answer;\n}\n\nfunction checkOrder(checkArr) {\n    for (let i = 0; i < checkArr.length; i++) if (checkArr[i] !== i) return false\n    return true\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/49993"
  },
  {
    "id": "92342",
    "name": "양궁대회",
    "fileName": "양궁대회&92342&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\n// 문제 풀이 전략\n// 1. 라이언이 쏠 수 있는 모든 경우를 비교한다.\n// 2. 10점부터 0점 순으로 어피치와 라이언을 비교해 가면서, 라이언이 해당 점수를 이길지, 비길지, 질지를 결정하며 가능한 경우를 만들어 간다.\n// 3. 이기는 경우는 화살을 어피치 + 1 개, 비기는 경우는 어피치와 동일한 개수를 소모하고, 지는 경우는 화살을 쏘지 않는다.\n// 4. 단, 0점에 도달하기 전에 화살을 모두 소진하면 더이상 쏠 화살이 없으므로 나머지 점수는 쏘지 않은 것으로 한다. 마찬가지로 0점에 도달하였는데 화살이 남아있더라면, 남은 화살을 모두 0점에 쏜다.\n// 5. 따라서 [지금까지 화살을 쏜 상황, 현재 검사중인 점수, 남은 화살 수]를 파라미터로 갖는 재귀함수를 구현하면 모든 경우를 검사할 수 있다.\n// 6. 모든 경우가 구해졌다면, 어피치와 라이언의 점수차가 가장 큰 경우들만 남긴다\n// 7. 가장 큰 경우들이 여러개라면 각 경우들을 중 마지막으로 쏜 화살의 점수 배점이 낮은 경우를 우선적으로 정렬한다.\n// RETURN. 정렬이 완료되면 가장 우선순위가 높은 경우를 반환한다.\nfunction solution(possibleArrows, apeachComb) {\n  const compareTable = apeachComb.map(apeachArrow => ({\n    apeachArrow,\n    ryanArrow: 0,\n  }));\n  const possibleRyanTable = getPossibleRyanTable(compareTable, 0, possibleArrows);\n  const maxScoreDiff = Math.max(...possibleRyanTable.flatMap(({ scoreDiff }) => scoreDiff));\n  const maxRyanTables = possibleRyanTable.filter(({ scoreDiff }) => scoreDiff === maxScoreDiff);\n  if (maxScoreDiff <= 0) return [-1];\n  const getIndexOfLastArrow = arrowTable =>\n    arrowTable.length -\n    arrowTable\n      .slice()\n      .reverse()\n      .findIndex(x => x !== 0);\n  return maxRyanTables.sort((a, b) => getIndexOfLastArrow(b.ryanTable) - getIndexOfLastArrow(a.ryanTable))[0].ryanTable;\n}\nfunction getPossibleRyanTable(compareTable, currentIndex, numberOfArrowLeft) {\n  const { apeachArrow } = compareTable[currentIndex];\n  const lastIndex = compareTable.length - 1;\n  const possibleRyanArrows = [\n    0,\n    numberOfArrowLeft > apeachArrow && apeachArrow + 1,\n    numberOfArrowLeft >= apeachArrow && apeachArrow,\n  ];\n\n  if (currentIndex === lastIndex || numberOfArrowLeft === 0) {\n    if (numberOfArrowLeft > 0) {\n      compareTable[compareTable.length - 1] = {\n        apeachArrow,\n        ryanArrow: numberOfArrowLeft,\n      };\n    }\n    const appeachScore = compareTable.reduce(\n      (acc, { apeachArrow, ryanArrow }, index) =>\n        apeachArrow >= ryanArrow && apeachArrow !== 0 ? acc + 10 - index : acc,\n      0\n    );\n    const ryanScore = compareTable.reduce(\n      (acc, { apeachArrow, ryanArrow }, index) => (ryanArrow > apeachArrow ? acc + 10 - index : acc),\n      0\n    );\n    return [\n      {\n        scoreDiff: ryanScore - appeachScore,\n        ryanTable: compareTable.flatMap(({ ryanArrow }) => ryanArrow),\n      },\n    ];\n  }\n  return [\n    ...possibleRyanArrows.flatMap(ryanUsedArrow => {\n      const nextCompareTable = [...compareTable];\n      nextCompareTable.splice(currentIndex, 1, {\n        apeachArrow,\n        ryanArrow: ryanUsedArrow,\n      });\n      return getPossibleRyanTable(nextCompareTable, currentIndex + 1, numberOfArrowLeft - ryanUsedArrow);\n    }),\n  ];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/92342"
  },
  {
    "id": "12981",
    "name": "영어 끝말잇기",
    "fileName": "영어-끝말잇기&12981&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, words) {\n    var answer = [];\n    let turn = 1\n    for (let i = 1; i < words.length; i++) {\n        let pass = (words[i][0] === words[i - 1][words[i - 1].length - 1]) && !(words.slice(0, i).includes(words[i]))\n        if (i % n === 0) turn++\n        if (!pass) return [i % n + 1, turn]\n    }\n    return [0, 0];\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12981"
  },
  {
    "id": "12985",
    "name": "예상 대진표",
    "fileName": "예상-대진표&12985&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\n\nfunction solution(n, a, b) {\n    let currentRound = 1;\n    const myNextNumber = (num) => Math.floor((num + 1) / 2)//내가 이긴경우 다음으로 가지게 될 번호\n    while (a !== b) { // a의 다음 번호가 b의 다음번호와 같아지면 끝난다.\n        if (myNextNumber(a) === myNextNumber(b)) break\n        a = myNextNumber(a)\n        b = myNextNumber(b)\n        currentRound++\n    }\n    return currentRound\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12985"
  },
  {
    "id": "42888",
    "name": "오픈채팅방",
    "fileName": "오픈채팅방&42888&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(record) {\n    var answer = [];\n    const users = {}\n    record.map(history => {\n        const [action, id, name] = history.split(' ')\n        if (action !== 'Leave') users[id] = name\n    })\n    record.map(history => {\n        const [action, id, name] = history.split(' ')\n        if (action === 'Enter') answer.push(`${users[id]}님이 들어왔습니다.`)\n        if (action === 'Leave') answer.push(`${users[id]}님이 나갔습니다.`)\n    })\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42888"
  },
  {
    "id": "12909",
    "name": "올바른 괄호",
    "fileName": "올바른-괄호&12909&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1(🎩 refactor 220425) - codeisneverodd\nfunction solution(s) {\n  let opened = 0;\n  for (const bracket of s) {\n    if (bracket === \"(\") opened += 1;\n    if (bracket === \")\") opened -= 1;\n    if (opened < 0) return false;\n  }\n  return opened === 0;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12909"
  },
  {
    "id": "42578",
    "name": "위장",
    "fileName": "위장&42578&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(clothes) {\n\tvar answer = 1;\n\tconst spyWear = {};\n\tfor (const clothNPart of clothes)\n\t\tspyWear[clothNPart[1]] = (spyWear[clothNPart[1]] || 0) + 1;\n\tfor (const part in spyWear) answer *= spyWear[part] + 1;\n\treturn answer - 1;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42578"
  },
  {
    "id": "70129",
    "name": "이진 변환 반복하기",
    "fileName": "이진-변환-반복하기&70129&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n  const removeZero = s => {\n    const removed = s\n      .split('')\n      .filter(n => n !== '0')\n      .join('');\n    return { removed, count: s.length - removed.length };\n  };\n\n  const convertToBinary = (s, turnCount, removedCount) => {\n    if (s === '1') return [turnCount, removedCount];\n    const { removed, count } = removeZero(s);\n    return convertToBinary(removed.length.toString(2), turnCount + 1, removedCount + count);\n  };\n\n  return convertToBinary(s, 0, 0);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/70129"
  },
  {
    "id": "86971",
    "name": "전력망을 둘로 나누기",
    "fileName": "전력망을-둘로-나누기&86971&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(n, wires) {\n  const hasOneOfWire = (tree, [a, b]) => tree.includes(a) || tree.includes(b);\n\n  const convertWiresToTree = wires => [...new Set(wires.flat())];\n\n  const generateTree = (wires, tree) => {\n    if (!wires.find(wire => hasOneOfWire(tree, wire))) return tree;\n\n    const nextWires = wires.filter(wire => !hasOneOfWire(tree, wire));\n    const nextTree = [...tree, ...convertWiresToTree(wires.filter(wire => hasOneOfWire(tree, wire)))];\n\n    return [...new Set(generateTree(nextWires, nextTree))];\n  };\n\n  let minDiff = Infinity;\n  const length = convertWiresToTree(wires).length;\n\n  wires.forEach((_, i) => {\n    const [initWire, ...remainWires] = wires.filter((_, j) => j !== i);\n    const lengthA = generateTree(remainWires, convertWiresToTree([initWire])).length;\n    const diff = Math.abs(lengthA - (length - lengthA));\n    minDiff = Math.min(diff, minDiff);\n  });\n\n  return minDiff;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/86971"
  },
  {
    "id": "12980",
    "name": "점프와 순간 이동",
    "fileName": "점프와-순간-이동&12980&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    var ans = 0;\n    while (n > 0) {\n        if (n % 2 !== 0) {\n            n = (n - 1) / 2\n            ans++\n        } else {\n            n = n / 2\n        }\n    }\n    return ans;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12980"
  },
  {
    "id": "42860",
    "name": "조이스틱",
    "fileName": "조이스틱&42860&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(name) {\n    var answer = 0;\n    const length = name.length;\n    let upDownCount = 0\n    let leftRightCountList = [length - 1]//한 방향으로 쭉 갔을 때\n    for (let i = 0; i < length; i++) upDownCount += minUpOrDownCount(name[i])\n    for (let startOfA = 0; startOfA < name.length; startOfA++) {\n        let endOfA = startOfA + 1;\n        while (endOfA < length && name[endOfA] === 'A') endOfA++;\n        const [moveToStartOfA, moveToEndOfA] = [startOfA, length - endOfA]\n        leftRightCountList.push(moveToStartOfA * 2 + moveToEndOfA)// 0 -> A.., 0 <- A.., ..A <- -1\n        leftRightCountList.push(moveToEndOfA * 2 + moveToStartOfA)//시작부터 뒤로 가는 경우 ..A <- -1, ..A -> -1, 0 -> A..\n    }\n    answer = upDownCount + Math.min(...leftRightCountList)\n    return answer;\n}\n\nfunction minUpOrDownCount(destination) {\n    const Alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    const index = Alphabet.indexOf(destination)\n    return Math.min(index, Alphabet.length - index)\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42860"
  },
  {
    "id": "92341",
    "name": "주차 요금 계산",
    "fileName": "주차-요금-계산&92341&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - ljw0096\n\nfunction solution(fees, records) {\n  const answer = []\n\n  const parkingTable = getParkingTable(records)\n  const sortedKeys = Object.keys(parkingTable).sort()\n\n  for (const targetCar of sortedKeys) {\n    if (parkingTable[targetCar].length % 2 === 1) {\n      parkingTable[targetCar].push(['23:59', 'OUT'])\n    }\n    const totalTime = getTotalTime(parkingTable, targetCar)\n    const fee = calculateFee(totalTime, fees)\n    answer.push(fee)\n  }\n\n  return answer\n}\n\nfunction getParkingTable(records) {\n  const parkingTable = {}\n\n  records.forEach((val) => {\n    const info = val.split(' ')\n    if (Object.keys(parkingTable).includes(info[1])) {\n      parkingTable[info[1]].push([info[0], info[2]])\n    } else {\n      parkingTable[info[1]] = [[info[0], info[2]]]\n    }\n  })\n\n  return parkingTable\n}\n\nfunction getTotalTime(parkingTable, targetCar) {\n  let totalTime = 0\n  for (let i = 0; i < parkingTable[targetCar].length - 1; i += 2) {\n    totalTime += calculateTotalTime(\n      parkingTable[targetCar][i][0],\n      parkingTable[targetCar][i + 1][0]\n    )\n  }\n  return totalTime\n}\n\nfunction calculateTotalTime(time1, time2) {\n  const [hour1, minute1] = time1.split(':').map((val) => parseInt(val))\n  const [hour2, minute2] = time2.split(':').map((val) => parseInt(val))\n\n  return hour2 * 60 + minute2 - (hour1 * 60 + minute1)\n}\n\nfunction calculateFee(totalTime, feeInfo) {\n  let fee = 0\n  if (feeInfo[0] >= totalTime) {\n    fee = feeInfo[1]\n  } else {\n    fee =\n      feeInfo[1] + Math.ceil((totalTime - feeInfo[0]) / feeInfo[2]) * feeInfo[3]\n  }\n  return fee\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/92341"
  },
  {
    "id": "12936",
    "name": "줄 서는 방법",
    "fileName": "줄-서는-방법&12936&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(n, k) {\n  const getFactorial = n => {\n    const result = [1, 1, 2, ...Array(n - 2)];\n    result.forEach((_, i) => {\n      if (i > 2) result[i] = result[i - 1] * i;\n    });\n    return result;\n  };\n\n  const getDivision = (dividend, divisor) => {\n    const quotient = Math.floor(dividend / divisor);\n    const remainder = dividend % divisor;\n    return [quotient, remainder];\n  };\n\n  const stepCount = getFactorial(n).reverse();\n\n  const generateSteps = (k, step) => {\n    const [q, r] = getDivision(k, stepCount[step]);\n    if (r === 0) return [q];\n    return [q, ...generateSteps(r, step + 1)];\n  };\n\n  const answer = [];\n\n  const steps = generateSteps(k - 1, 0);\n\n  const notUsedNums = Array.from({ length: n }, (_, i) => i + 1);\n\n  steps.slice(1).forEach(q => {\n    answer.push(notUsedNums[q]);\n    notUsedNums.splice(q, 1);\n  });\n\n  return [...answer, ...notUsedNums];\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12936"
  },
  {
    "id": "12973",
    "name": "짝지어 제거하기",
    "fileName": "짝지어-제거하기&12973&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = -1;\n    let notPairStack = []\n    for (let i = 0; i < s.length; i++) notPairStack[notPairStack.length - 1] === s[i] ? notPairStack.pop() : notPairStack.push(s[i])\n    answer = notPairStack.length === 0 ? 1 : 0\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12973"
  },
  {
    "id": "12939",
    "name": "최댓값과 최솟값",
    "fileName": "최댓값과-최솟값&12939&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = '';\n    const arr = s.split(' ')\n    answer = Math.min(...arr) + ' ' + Math.max(...arr)\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12939"
  },
  {
    "id": "12941",
    "name": "최솟값 만들기",
    "fileName": "최솟값-만들기&12941&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(A, B) {\n    var answer = 0;\n    A = A.sort((a, b) => a - b)\n    B = B.sort((a, b) => b - a)\n    for (let i = 0; i < A.length; i++) answer += A[i] * B[i]\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12941"
  },
  {
    "id": "42842",
    "name": "카펫",
    "fileName": "카펫&42842&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(brown, yellow) {\n    var answer = [];\n    const size = brown + yellow\n    answer = widthHeightPair(size).filter(pair => (pair[0] + pair[1]) * 2 - 4 === brown)[0]\n    return answer;\n}\n\nfunction widthHeightPair(size) {\n    let result = []\n    for (let i = 1; i <= Math.sqrt(size); i++) if (size % i === 0) result.push([size / i, i])\n    return result\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42842"
  },
  {
    "id": "68936",
    "name": "쿼드압축 후 개수 세기",
    "fileName": "쿼드압축-후-개수-세기&68936&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - codeisneverodd\nfunction solution(arr) {\n  const quad = matrix => {\n    const length = matrix.length;\n    const half = length / 2;\n    const pass = matrix => matrix.every(row => row.every(v => v === matrix[0][0]));\n\n    if (pass(matrix)) return [matrix[0][0]];\n    if (length <= 2) return matrix;\n\n    const startPoints = [\n      [0, 0],\n      [0, half],\n      [half, 0],\n      [half, half],\n    ];\n\n    return startPoints.map(([r, c]) => quad(matrix.slice(r, r + half).map(row => row.slice(c, c + half))));\n  };\n  return quad(arr)\n    .flat(Infinity)\n    .reduce((a, c) => (c === 0 ? [a[0] + 1, a[1]] : [a[0], a[1] + 1]), [0, 0]);\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/68936"
  },
  {
    "id": "42883",
    "name": "큰 수 만들기",
    "fileName": "큰-수-만들기&42883&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(number, k) {\n    var answer = '';\n    let answerStack = [0]\n    let deleteCount = -1\n    for (let i = 0; i < number.length; i++) {\n        while (deleteCount < k && number[i] > answerStack[answerStack.length - 1]) {\n            answerStack.pop()\n            deleteCount++\n        }\n        if (answerStack.length < number.length - k) answerStack.push(number[i])\n    }\n    answer = answerStack.join('')\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42883"
  },
  {
    "id": "43165",
    "name": "타겟 넘버",
    "fileName": "타겟-넘버&43165&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1(🎩 refactor 220830) - codeisneverodd\nfunction solution(numbers, target) {\n  const dfs = (index, sum) => {\n    if (index === numbers.length) return sum === target ? 1 : 0;\n    return dfs(index + 1, sum + numbers[index]) + dfs(index + 1, sum - numbers[index]);\n  };\n  return dfs(0, 0);\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/43165"
  },
  {
    "id": "64065",
    "name": "튜플",
    "fileName": "튜플&64065&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(s) {\n    var answer = [];\n    let sets = s\n        .slice(2, -2)\n        .split('},{')\n        .map(set => set.split(',').map(x => parseInt(x)))\n        .sort((a, b) => a.length - b.length)\n    for (const set of sets) answer.push(...set.filter(x => !answer.includes(x)))\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/64065"
  },
  {
    "id": "42587",
    "name": "프린터",
    "fileName": "프린터&42587&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(priorities, location) {\n    var answer = 0;\n    let documents = priorities.map((priority, index) => ({location: index, priority: priority}))\n    let locationPrinted = false\n    while (!locationPrinted) {\n        const shifted = documents.shift()\n        let printAvailable = true\n        if (documents.some((document) => shifted.priority < document.priority)) printAvailable = false\n        if (printAvailable) {\n            answer += 1\n            if (shifted.location === location) locationPrinted = true\n        } else {\n            documents.push(shifted)\n        }\n    }\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42587"
  },
  {
    "id": "87946",
    "name": "피로도",
    "fileName": "피로도&87946&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - pereng11\n//완전 탐색, greedy O(N^2)\nfunction solution(currentFatigue, dungeons) {\n  return getMaxCount(currentFatigue, 0, dungeons);\n}\n\nfunction getMaxCount(currentFatigue, visitedCount, dungeons) {\n  const possibleDungeons = dungeons.filter(([minNeededFatigue, _]) => minNeededFatigue <= currentFatigue);\n  if (possibleDungeons.length === 0) return visitedCount;\n\n  const maxCount = possibleDungeons.reduce((prevCount, curr, currentIndex) => {\n    const [_, usedFatigue] = curr;\n    const nextDungeons = possibleDungeons.filter((_, index) => index !== currentIndex);\n    const currentCount = getMaxCount(\n      currentFatigue - usedFatigue,\n      visitedCount + 1,\n      nextDungeons\n    );\n    return Math.max(currentCount, prevCount);\n  }, 0);\n\n  return maxCount;\n}\n\n\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/87946"
  },
  {
    "id": "12945",
    "name": "피보나치 수",
    "fileName": "피보나치-수&12945&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    var answer = 0;\n    answer = fibonacci1234567(n)\n    return answer;\n}\n\nfunction fibonacci1234567(n) { //재귀적으로 하면 시간초과\n    let fiboArr = new Array(n + 1).fill(0)\n    fiboArr[0] = 0\n    fiboArr[1] = 1\n    for (let i = 2; i <= n; i++) fiboArr[i] = (fiboArr[i - 1] + fiboArr[i - 2]) % 1234567 //1234567로 나눈 나머지로 하지 않으면 정수범위 초과\n    return fiboArr[n]\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12945"
  },
  {
    "id": "12946",
    "name": "하노이의 탑",
    "fileName": "하노이의-탑&12946&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n  return move(1, 3, 2, n);\n}\nconst move = (departure, destination, waypoint, numberOfPlate) => {\n  if (numberOfPlate === 1) return [[departure, destination]];\n  return [\n    ...move(departure, waypoint, destination, numberOfPlate - 1),\n    ...move(departure, destination, waypoint, 1),\n    ...move(waypoint, destination, departure, numberOfPlate - 1),\n  ];\n};\n//재귀를 생각해보기에 좋은 문제입니다.\n//추천 레퍼런스 https://shoark7.github.io/programming/algorithm/tower-of-hanoi\n/*\nn개가 있다면\n1. 1->2로 n-1개를 옮김\n2. 1->3으로 가장 큰 1개를 옮김\n3. 2->1로 n-2개를 옮김\n4. 2->3으로 2번에 있는 것 중 가장 큰 1개를 옮김\n의 반복\n\n결국 무엇이든  a -> b 로 n 를 옮기는 동작의 반복이므로 이를 재귀로 표현하면 됨.\na->b 로 n 을 옮기는 것은 a->c로 n-1개를 옮겨놓고, a->b로 하나를 옮긴 후, c->b로 n-1개를 옮기는 것의 반복 \n함수에서 a는 depature(출발지), b는 destination(도착지), c는 waypoint(경유지)로 작성되어있음.\n*/\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12946"
  },
  {
    "id": "77485",
    "name": "행렬 테두리 회전하기",
    "fileName": "행렬-테두리-회전하기&77485&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(rows, columns, queries) {\n    var answer = [];\n    let matrix = new Array(rows)\n    for (let i = 0; i < rows; i++) matrix[i] = new Array(columns)\n    for (let i = 0; i < rows; i++) for (let j = 0; j < columns; j++) matrix[i][j] = i * columns + j + 1\n    for (const query of queries) {\n        let order = []\n        const [row1, col1, row2, col2] = [query[0] - 1, query[1] - 1, query[2] - 1, query[3] - 1]\n        //fill order (row1->row2, col1->col2, row2->row2, col2->col1)\n        for (let i = row1; i <= row2; i++) order.push(matrix[i][col1])\n        for (let i = col1 + 1; i <= col2; i++) order.push(matrix[row2][i])\n        for (let i = row2 - 1; i >= row1; i--) order.push(matrix[i][col2])\n        for (let i = col2 - 1; i > col1; i--) order.push(matrix[row1][i])\n        //rotate clockwise\n        order.push(order.shift())\n        answer.push(Math.min(...order))\n        //change value in matrix\n        for (let i = row1; i <= row2; i++) matrix[i][col1] = order.shift()\n        for (let i = col1 + 1; i <= col2; i++) matrix[row2][i] = order.shift()\n        for (let i = row2 - 1; i >= row1; i--) matrix[i][col2] = order.shift()\n        for (let i = col2 - 1; i > col1; i--) matrix[row1][i] = order.shift()\n    }\n    return answer;\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/77485"
  },
  {
    "id": "12949",
    "name": "행렬의 곱셈",
    "fileName": "행렬의-곱셈&12949&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(arr1, arr2) {\n    const [row, col] = [arr1.length, arr2[0].length]\n    let answer = new Array(row);\n    for (let i = 0; i < row; i++) answer[i] = new Array(col)\n    //arr1의 열의 개수 = arr2의 행의 개수, arr1의 i번째 행과 arr2의 j번째 열의 원소들을 곱한 것들의 합이 answer[i][j] 값\n    for (let i = 0; i < row; i++) {\n        for (let j = 0; j < col; j++) {\n            answer[i][j] = arr1[i].reduce((sum, arr1Value, rowIndex) => sum + arr1Value * arr2[rowIndex][j], 0)\n        }\n    }\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12949"
  },
  {
    "id": "42890",
    "name": "후보키",
    "fileName": "후보키&42890&.js",
    "level": 2,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(relation) {\n    //1. 가능한 조합을 1개~Attribute개수 만큼 찾는다.\n    //2. 해당 개수의 조합이 키가 될 수 있는지 검사하고, 가능하면 후보키에 추가한다.\n    //3. 단 추가하려고 할 때, 후보키에 있는 값이 자신의 부분 집합이 될 수 있으면 추가하지 않는다.\n    const keys = []\n    const totalAttrCount = relation[0].length\n    const indexList = Array.from(Array(totalAttrCount), (x, index) => index) // [0,1,2,3 ... totalAttrCount-1]\n\n    //Fn for 2. 해당 조합으로 각 row의 attribute를 모았을 때 중복이 있는지를 반환하는 함수\n    const isUnique = (relation, attrIndexComb) => {\n        let result = Array.from(Array(relation.length), x => '')\n        for (const attrIndex of attrIndexComb) {\n            relation.forEach((row, rowIndex) => result[rowIndex] += row[attrIndex]) //Set를 이용해 중복 검사를 하기 위해 result에 string으로 넣음.\n        }\n        return result.length === [...new Set(result)].length\n    }\n\n    //Fn for 3. keys에 현재 구한 검사할 조합의 부분집합이 존재하는지 반환, 단 keys에 들어있는 각 조합의 크기는 현재 검사할 조합의 크기보다 작다.\n    const isMinimal = (attrComb) => {\n        for (const key of keys) if (key.every(attr => attrComb.includes(attr))) return false\n        return true\n    }\n\n    //가능한 모든 조합을 검사\n    for (let attrCount = 1; attrCount <= totalAttrCount; attrCount++) {\n        const combinations = getCombinations(indexList, attrCount)\n        for (const attrComb of combinations) {\n            if (isMinimal(attrComb) && isUnique(relation, attrComb)) keys.push(attrComb)\n        }\n    }\n\n    return keys.length\n}\n\n//Fn for 1. 조합을 반환하는 함수\nconst getCombinations = (array, selectNumber) => {\n    const result = [];\n    if (selectNumber === 1) {\n        return array.map((element) => [element]);\n    }\n    array.forEach((fixed, index, origin) => {\n        const restCombinations = getCombinations(origin.slice(index + 1), selectNumber - 1);\n        const attached = restCombinations.map((restCombination) => [fixed, ...restCombination]);\n        result.push(...attached);\n    });\n    return result;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42890"
  },
  {
    "id": "12900",
    "name": "2 x n 타일링",
    "fileName": "2-x-n-타일링&12900&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(n) {\n  let dp = [0, 1, 2] // n이 1, 2일때는 바로 답을 출력,\n  if (n>2){ // n이 3 이상이면 필요한 만큼의 수 까지만 수를 만들어준다.\n      for (let i=3; i<=n; i++){\n          dp.push((dp[i-1] + dp[i-2]) % 1000000007);\n      }\n  }\n  return dp[n]\n}\n/* \nn이 1일땐 1, 2일땐 2, 3일땐 3, 4일땐 5 . . 의 식이 보인다.\nn = (n - 1) + (n - 2)의 식으로 구할 수 있고,\n제한 사항을 주의해서 풀어보자. */",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12900"
  },
  {
    "id": "12952",
    "name": "N Queen",
    "fileName": "N-Queen&12952&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n) {\n    /*\n    1. 0번째 행에 0번째 queen을 놓는다.\n    2. 그 다음 행의 퀸은 이전 퀸들의 범위와 겹치지 않는 곳에 놓는다. 퀸은 한 행에 반드시 하나 두어야한다.\n    3. 마지막 열까지 도달하면 성공으로 간주하고 answer에 1을 더한다.\n    4. 0번째 queen의 위치를 바꿔가며 모두 시도한다.\n    4. 단, 체스판은 일차원 배열로 선언하고 index = 행, 값 = 열 로 생각한다.\n    */\n    let answer = 0;\n    const canBePlacedOn = (chess, currentRow) => {\n        //해당 행에 둔 queen이 유효한지\n        for (let prevRow = 0; prevRow < currentRow; prevRow++) {\n            const onDiagonal = currentRow - prevRow === Math.abs(chess[currentRow] - chess[prevRow])\n            const onStraight = chess[prevRow] === chess[currentRow]\n            if (onDiagonal || onStraight) return false\n        }\n        return true\n    }\n    const placeQueen = (chess, currentRow) => {\n        //queen을 배치하다가 끝 행에 도착하면 1을 리턴, 도착하지 못하면 0을 리턴하여, 재귀적으로 모든 경우를 합하여 리턴\n        let count = 0\n        if (currentRow === chess.length) return 1\n        for (let currentQueen = 0; currentQueen < n; currentQueen++) {\n            //queen을 우선 배치한 후 가능한지 살펴본다.\n            chess[currentRow] = currentQueen\n            if (canBePlacedOn(chess, currentRow)) count += placeQueen(chess, currentRow + 1)\n        }\n        return count\n    }\n    for (let firstQueen = 0; firstQueen < n; firstQueen++) {\n        const chess = new Array(n).fill(-1)\n        chess[0] = firstQueen\n        answer += placeQueen(chess, 1)\n    }\n    return answer;\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12952"
  },
  {
    "id": "49189",
    "name": "가장 먼 노드",
    "fileName": "가장-먼-노드&49189&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, edge) {\n    const graph = Array.from(Array(n + 1), () => [])\n    for (const [src, dest] of edge) {\n        graph[src].push(dest)\n        graph[dest].push(src)\n    }\n    const distance = Array(n + 1).fill(0)\n    distance[1] = 1\n    const toBeSearched = [1]\n    while (toBeSearched.length > 0) {\n        const src = toBeSearched.shift()\n        for (const dest of graph[src]) {\n            if (distance[dest] === 0) {\n                distance[dest] = distance[src] + 1\n                toBeSearched.push(dest)\n            }\n        }\n    }\n    return distance.filter(x => x === Math.max(...distance)).length\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/49189"
  },
  {
    "id": "43162",
    "name": "네트워크",
    "fileName": "네트워크&43162&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, computers) {\n    let answer = 0\n    const visited = new Array(n).fill(false)\n    const newNetwork = (startComputer) => {\n        //새로운 네트워크를 만들 시작 컴퓨터를 파라미터로 받는다.\n        const toBeVisited = [startComputer]\n        while (toBeVisited.length > 0) {\n            //시작 컴퓨터로부터 방문 가능한 컴퓨터를 모두 방문하며 해당 컴퓨터의 visited를 true로 바꾼다\n            const currentComputer = toBeVisited.pop()\n            visited[currentComputer] = true\n            for (let nextComputer = 0; nextComputer < n; nextComputer++) {\n                if (!visited[nextComputer] && computers[currentComputer][nextComputer]) {\n                    toBeVisited.push(nextComputer)\n                }\n            }\n        }\n    }\n\n    for (let startComputer = 0; startComputer < n; startComputer++) {\n        if (!visited[startComputer]) {\n            newNetwork(startComputer)\n            //새로운 네트워크를 생성할 때마다 정답을 1 증가시킨다.\n            answer++\n        }\n    }\n    return answer\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/43162"
  },
  {
    "id": "42884",
    "name": "단속카메라",
    "fileName": "단속카메라&42884&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(routes) {\n  let cctv = 1;  // cctv의 개수는 최소 1개\n  routes.sort((a, b) => a[0] - b[0]); // 고속도로 진입 시점을 기준으로 오름차순 정렬\n  // [ [ -20, -15 ], [ -18, -13 ], [ -14, -5 ], [ -5, -3 ] ]\n  let out = routes[0][1]; // -15\n  // 나간 시점(out)은 첫 차량의 나간시점으로 초기화\n  \n  for(let i = 1; i < routes.length; i++) {\n    // 나간 시점(out)보다 현재 차량의 진입이 느리다면 카메라 추가 설치\n    if(out < routes[i][0]) {\n      cctv++;\n      out = routes[i][1]; // out 시점 업데이트\n    }\n    \n    // 나간 시점(out)이 현재 차량의 진출시점보다 큰 경우 \n    if(out > routes[i][1]) {\n      out = routes[i][1]; // out 시점 업데이트 \n    }\n  }\n  \n  return cctv;\n}\n// 그리디\n\n// 우리는 카메라를 최소로 설치 해야합니다. 그러기 위해서는 고속도로 진입 시점을 기준으로 오름차순 정렬을(빨리 진입한 순) 합니다.\n// 이렇게 되면 배열에 있는 모든 고속도로 진입 시점은 배열의 첫번째 고속도로 진입 시점보다 더 뒤에 있습니다. 그러므로 우리는 \n// 나간시점만 검사 해주면 됩니다.\n\n// 먼저 첫번째 routes의 고속도로를 빠져나간 시점을 out 변수에 담아줍니다.\n// 이 out 변수를 두번째 routes의 고속도로를 빠져나간 시점과 비교하여 out 변수보다 route[i][1]가 크면 ( 나간 시간이 느리면)\n// cctv를 하나 늘려줍니다. , out 변수를 갱신 하며 세번째, 네번째도 계속 비교해줍니다.",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42884"
  },
  {
    "id": "42579",
    "name": "베스트앨범",
    "fileName": "베스트앨범&42579&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(genres, plays) {\n    var answer = [];\n    const songs = []\n    const genreSumHash = {}\n    const genreSumArr = []\n\n    //고유번호, 장르, 플레이수를 담은 songs\n    genres.forEach((genre, id) => {\n        songs.push({id: id, genre: genre, play: plays[id]})\n        genreSumHash[genre] = genreSumHash[genre] === undefined ? plays[id] : genreSumHash[genre] + plays[id]\n    })\n\n    //장르별 플레이수 합으로 정렬하기 위해 생성한 배열 genreSumArr\n    for (const genre in genreSumHash) genreSumArr.push([genre, genreSumHash[genre]])\n    genreSumArr.sort((a, b) => b[1] - a[1])\n\n    //각 장르안에서 각 노래의 play수가 높은 순으로 정렬하고 앞에서부터 2개까지 정답에 고유번호를 push\n    for (const genre of genreSumArr) {\n        const sorted = songs.filter(song => song.genre === genre[0]).sort((a, b) => b.play - a.play)\n        for (let i = 0; i < 2 && i < sorted.length; i++) answer.push(sorted[i].id)\n    }\n    return answer;\n}\n\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42579"
  },
  {
    "id": "43164",
    "name": "여행경로",
    "fileName": "여행경로&43164&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(tickets) {\n    const routes = [] //최종 가능 루트들을 담을 배열\n    const makeRoutes = (currentDepart, remainTickets, currentRoute) => {\n        //현재 출발지, 남은 티켓들, 현재 까지 만든 루트를 기반으로 경로를 만들어 가는 재귀 함수\n        if (remainTickets.length > 0) {\n            remainTickets.forEach(([depart, nextDepart], index) => {\n                if (depart === currentDepart)\n                    //현재 출발지와 같은 출발지를 가진 티켓이 있다면, 해당 티켓을 사용하고 해당 티켓의 도착지를 다음 출발지로 지정\n                    makeRoutes(\n                        nextDepart,\n                        [...remainTickets.slice(0, index), ...remainTickets.slice(index + 1)],\n                        [...currentRoute, currentDepart])\n            })\n        } else {\n            //티켓을 모두 사용하면 최종 가능 루트에 포함\n            routes.push([...currentRoute, currentDepart])\n        }\n    }\n    makeRoutes(\"ICN\", tickets, [])\n    return routes.sort()[0]\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/43164"
  },
  {
    "id": "42628",
    "name": "이중우선순위큐",
    "fileName": "이중우선순위큐&42628&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - jaewon1676\nfunction solution(operations) {\n  var answer = [];\n  for (let i = 0; i < operations.length; i++) {\n    // 숫자 삽입\n    if (operations[i][0] == 'I') {\n      let m = operations[i].substring(2, operations[i].length);\n      answer.push(m);\n    }\n    // if 최댓값 삭제\n    else if (operations[i][0] == 'D' && operations[i][2] == '1' && operations.length > 0) {\n      answer.pop();\n    }\n    // if 최솟값 삭제\n    else if (operations[i][0] == 'D' && operations[i][2] == '-' && operations[i][3] == '1' && operations.length > 0) {\n      answer.shift();\n    }\n\n    answer.sort((a, b) => {\n      return a - b;\n    });\n  }\n  if (answer.length == 0) return [0, 0];\n  else {\n    return [parseInt(answer.pop()), parseInt(answer.shift())];\n  }\n}\n/* 풀이 과정\n1. 연산 처리를 구별하기 위해 배열의 0번째 자리, 2번째 자리에 있는 등을 비교하여 조건에 따른 명령을 실행한다.\n2. answer 배열을 정렬 해준다\n3. 큐가 비어있으면 ( length == 0 ) 0을 반환. , 그렇지 않으면 [최댓값, 최솟값]을 반환한다.\n*/\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/42628"
  },
  {
    "id": "43238",
    "name": "입국심사",
    "fileName": "입국심사&43238&.js",
    "level": 3,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\nfunction solution(n, times) {\n  //최소로 걸릴 수 있는 시간 left, 최대로 걸릴 수 있는 시간 right\n  let [left, right] = [1, Math.max(...times) * n];\n  while (left <= right) {\n    const mid = Math.floor((left + right) / 2);\n    const sum = times.reduce((acc, time) => acc + Math.floor(mid / time), 0);\n    //sum은 mid 시간 동안 처리 할 수 있는 사람의 수\n    if (sum < n) {\n      left = mid + 1;\n    } else {\n      right = mid - 1;\n    }\n  }\n  // left 가 right를 넘어갔다는 것은 left가 n보다 크거나 같아져서 n명을 수용할 수 최소값이 되있다는 것이다.\n  return left;\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/43238"
  },
  {
    "name": "가사 검색.js",
    "fileName": "가사-검색.js",
    "level": 4,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - ryong9rrr\nclass Node {\n  constructor(value = '') {\n    this.value = value\n    this.children = new Map()\n    this.count = 0\n  }\n}\n\nclass Trie {\n  constructor() {\n    this.root = new Node()\n  }\n\n  insert(string) {\n    let currentNode = this.root\n    for (const char of string) {\n      if (!currentNode.children.has(char)) {\n        currentNode.children.set(char, new Node(currentNode.value + char))\n      }\n      currentNode = currentNode.children.get(char)\n      currentNode.count++\n    }\n  }\n\n  startsWithCount(prefix) {\n    let currentNode = this.root\n    for (const char of prefix) {\n      if (!currentNode.children.has(char)) {\n        return 0\n      }\n      currentNode = currentNode.children.get(char)\n    }\n    return currentNode.count\n  }\n}\n\nfunction reverseString(string) {\n  return [...string].reverse().join('')\n}\n\nfunction solution(words, queries) {\n  const table = {}\n  const reverseTable = {}\n  const counter = {}\n\n  words.forEach((word) => {\n    const key = word.length\n    if (!table[key]) table[key] = new Trie()\n    if (!reverseTable[key]) reverseTable[key] = new Trie()\n    table[key].insert(word)\n    reverseTable[key].insert(reverseString(word))\n    if (counter[key] === undefined) counter[key] = 0\n    counter[key]++\n  })\n\n  return queries.map((query) => {\n    const key = query.length\n    if (!table[key]) {\n      return 0\n    }\n    const tQuery = query.replace(/\\?/g, '')\n    if (!tQuery) {\n      return counter[key]\n    }\n    if (query[query.length - 1] === '?') {\n      return table[key].startsWithCount(tQuery)\n    }\n    return reverseTable[key].startsWithCount(reverseString(tQuery))\n  })\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/undefined"
  },
  {
    "id": "12983",
    "name": "단어 퍼즐",
    "fileName": "단어-퍼즐&12983&.js",
    "level": 4,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - codeisneverodd\n//코드 참고자료: https://velog.io/@longroadhome/%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%A8%B8%EC%8A%A4-LV.4-%EB%8B%A8%EC%96%B4-%ED%8D%BC%EC%A6%90\nfunction solution(strs, t) {\n  const tLength = t.length; //자주 쓰는 값 미리 계산\n  //Infinity 로 선언을 해야 조합이 불가능한 영역의 값을 무한으로 두고, 그 영역에 하나를 더해도 불가능하다는 것을 Infinity로 표현할 수 있게 된다.\n  const minCountToIndex = new Array(tLength).fill(Infinity);\n  for (let currentIndex = 0; currentIndex < tLength; currentIndex++) {\n    //내가 검사할 부분은 t의 0~currentIndex 영역\n    const currentSlice = t.slice(0, currentIndex + 1);\n    for (const str of strs) {\n      //현재 영역이 strs에 있는 조각들 중 하나로 끝난다면\n      if (currentSlice.endsWith(str)) {\n        //frontLength 는 str 조각을 제외한 앞 쪽의 남은 조각의 길이\n        const frontLength = currentIndex - str.length + 1;\n        if (frontLength === 0) {\n          //앞쪽에 남은 것이 없다면, 현재 검사중인 영역 = strs에 있는 조각\n          minCountToIndex[currentIndex] = 1;\n        } else {\n          //앞쪽에 남은 것이 있다면, 현재 검사중이 영역까지 필요한 조각 수는, 지금까지 구한 최소 값과 지금 구한 값 중 최소값\n          minCountToIndex[currentIndex] = Math.min(minCountToIndex[currentIndex], minCountToIndex[frontLength - 1] + 1);\n        }\n      }\n    }\n  }\n  //마지막 영역이 Infinity 이면 만들기 불가능한 단어, 아니라면 마지막 영역의 값을 리턴\n  return minCountToIndex[tLength - 1] === Infinity ? -1 : minCountToIndex[tLength - 1];\n}\n\n//리드미 테스트용 코멘트\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12983"
  },
  {
    "name": "무지의 먹방 라이브.js",
    "fileName": "무지의-먹방-라이브.js",
    "level": 4,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//더 좋은 풀이가 존재할 수 있습니다.\n// 1 - ryong9rrr\nfunction solution(food_times, k) {\n  const total = food_times.reduce((a, b) => a + b)\n  if (total <= k) {\n    return -1\n  }\n\n  // stack으로 풀기\n  const stack = food_times.map((time, i) => [time, i + 1]).sort(([timeA], [timeB]) => timeB - timeA)\n\n  let prev = 0\n  while (stack.length > 0 && k >= 0) {\n    const [time] = stack[stack.length - 1]\n    const acc = (time - prev) * stack.length\n    if (k < acc) {\n      break\n    }\n    stack.pop()\n    k -= acc\n    prev = time\n  }\n\n  const result = stack\n    .reverse()\n    .map(([_, order]) => order)\n    .sort((orderA, orderB) => orderA - orderB)\n  return result[k % result.length]\n}",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/undefined"
  },
  {
    "id": "12929",
    "name": "올바른 괄호의 갯수",
    "fileName": "올바른-괄호의-갯수&12929&.js",
    "level": 4,
    "code": "//https://github.com/codeisneverodd/programmers-coding-test\n//완벽한 정답이 아닙니다.\n// 1 - cg10036\nfunction solution(n) {\n    const fact = n => n ? BigInt(n) * fact(n - 1) : 1n;\n    return fact(n * 2) / (fact(n) * fact(n + 1));\n}\n",
    "link": "https://school.programmers.co.kr/learn/courses/30/lessons/12929"
  }
]
